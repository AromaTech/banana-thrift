/**
 * Autogenerated by Thrift Compiler (0.9.3)
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *  @generated
 */
#include "Reactions_types.h"

#include <algorithm>
#include <ostream>

#include <thrift/TToString.h>

namespace tech { namespace aroma { namespace thrift { namespace reactions {


MatcherAll::~MatcherAll() throw() {
}


uint32_t MatcherAll::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    xfer += iprot->skip(ftype);
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t MatcherAll::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("MatcherAll");

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(MatcherAll &a, MatcherAll &b) {
  using ::std::swap;
  (void) a;
  (void) b;
}

MatcherAll::MatcherAll(const MatcherAll& other0) {
  (void) other0;
}
MatcherAll& MatcherAll::operator=(const MatcherAll& other1) {
  (void) other1;
  return *this;
}
void MatcherAll::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "MatcherAll(";
  out << ")";
}


MatcherTitleIs::~MatcherTitleIs() throw() {
}


void MatcherTitleIs::__set_expectedTitle(const std::string& val) {
  this->expectedTitle = val;
}

uint32_t MatcherTitleIs::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->expectedTitle);
          this->__isset.expectedTitle = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t MatcherTitleIs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("MatcherTitleIs");

  xfer += oprot->writeFieldBegin("expectedTitle", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->expectedTitle);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(MatcherTitleIs &a, MatcherTitleIs &b) {
  using ::std::swap;
  swap(a.expectedTitle, b.expectedTitle);
  swap(a.__isset, b.__isset);
}

MatcherTitleIs::MatcherTitleIs(const MatcherTitleIs& other2) {
  expectedTitle = other2.expectedTitle;
  __isset = other2.__isset;
}
MatcherTitleIs& MatcherTitleIs::operator=(const MatcherTitleIs& other3) {
  expectedTitle = other3.expectedTitle;
  __isset = other3.__isset;
  return *this;
}
void MatcherTitleIs::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "MatcherTitleIs(";
  out << "expectedTitle=" << to_string(expectedTitle);
  out << ")";
}


MatcherTitleContains::~MatcherTitleContains() throw() {
}


void MatcherTitleContains::__set_substring(const std::string& val) {
  this->substring = val;
}

uint32_t MatcherTitleContains::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->substring);
          this->__isset.substring = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t MatcherTitleContains::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("MatcherTitleContains");

  xfer += oprot->writeFieldBegin("substring", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->substring);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(MatcherTitleContains &a, MatcherTitleContains &b) {
  using ::std::swap;
  swap(a.substring, b.substring);
  swap(a.__isset, b.__isset);
}

MatcherTitleContains::MatcherTitleContains(const MatcherTitleContains& other4) {
  substring = other4.substring;
  __isset = other4.__isset;
}
MatcherTitleContains& MatcherTitleContains::operator=(const MatcherTitleContains& other5) {
  substring = other5.substring;
  __isset = other5.__isset;
  return *this;
}
void MatcherTitleContains::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "MatcherTitleContains(";
  out << "substring=" << to_string(substring);
  out << ")";
}


MatcherBodyIs::~MatcherBodyIs() throw() {
}


void MatcherBodyIs::__set_expectedBody(const std::string& val) {
  this->expectedBody = val;
}

uint32_t MatcherBodyIs::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->expectedBody);
          this->__isset.expectedBody = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t MatcherBodyIs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("MatcherBodyIs");

  xfer += oprot->writeFieldBegin("expectedBody", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->expectedBody);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(MatcherBodyIs &a, MatcherBodyIs &b) {
  using ::std::swap;
  swap(a.expectedBody, b.expectedBody);
  swap(a.__isset, b.__isset);
}

MatcherBodyIs::MatcherBodyIs(const MatcherBodyIs& other6) {
  expectedBody = other6.expectedBody;
  __isset = other6.__isset;
}
MatcherBodyIs& MatcherBodyIs::operator=(const MatcherBodyIs& other7) {
  expectedBody = other7.expectedBody;
  __isset = other7.__isset;
  return *this;
}
void MatcherBodyIs::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "MatcherBodyIs(";
  out << "expectedBody=" << to_string(expectedBody);
  out << ")";
}


MatcherBodyContains::~MatcherBodyContains() throw() {
}


void MatcherBodyContains::__set_substring(const std::string& val) {
  this->substring = val;
}

uint32_t MatcherBodyContains::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->substring);
          this->__isset.substring = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t MatcherBodyContains::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("MatcherBodyContains");

  xfer += oprot->writeFieldBegin("substring", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->substring);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(MatcherBodyContains &a, MatcherBodyContains &b) {
  using ::std::swap;
  swap(a.substring, b.substring);
  swap(a.__isset, b.__isset);
}

MatcherBodyContains::MatcherBodyContains(const MatcherBodyContains& other8) {
  substring = other8.substring;
  __isset = other8.__isset;
}
MatcherBodyContains& MatcherBodyContains::operator=(const MatcherBodyContains& other9) {
  substring = other9.substring;
  __isset = other9.__isset;
  return *this;
}
void MatcherBodyContains::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "MatcherBodyContains(";
  out << "substring=" << to_string(substring);
  out << ")";
}


MatcherUrgencyEquals::~MatcherUrgencyEquals() throw() {
}


void MatcherUrgencyEquals::__set_urgency(const  ::tech::aroma::thrift::Urgency::type val) {
  this->urgency = val;
}

uint32_t MatcherUrgencyEquals::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast10;
          xfer += iprot->readI32(ecast10);
          this->urgency = ( ::tech::aroma::thrift::Urgency::type)ecast10;
          this->__isset.urgency = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t MatcherUrgencyEquals::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("MatcherUrgencyEquals");

  xfer += oprot->writeFieldBegin("urgency", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32((int32_t)this->urgency);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(MatcherUrgencyEquals &a, MatcherUrgencyEquals &b) {
  using ::std::swap;
  swap(a.urgency, b.urgency);
  swap(a.__isset, b.__isset);
}

MatcherUrgencyEquals::MatcherUrgencyEquals(const MatcherUrgencyEquals& other11) {
  urgency = other11.urgency;
  __isset = other11.__isset;
}
MatcherUrgencyEquals& MatcherUrgencyEquals::operator=(const MatcherUrgencyEquals& other12) {
  urgency = other12.urgency;
  __isset = other12.__isset;
  return *this;
}
void MatcherUrgencyEquals::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "MatcherUrgencyEquals(";
  out << "urgency=" << to_string(urgency);
  out << ")";
}


MatcherHostnameEquals::~MatcherHostnameEquals() throw() {
}


void MatcherHostnameEquals::__set_expectedHostname(const std::string& val) {
  this->expectedHostname = val;
}

uint32_t MatcherHostnameEquals::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->expectedHostname);
          this->__isset.expectedHostname = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t MatcherHostnameEquals::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("MatcherHostnameEquals");

  xfer += oprot->writeFieldBegin("expectedHostname", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->expectedHostname);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(MatcherHostnameEquals &a, MatcherHostnameEquals &b) {
  using ::std::swap;
  swap(a.expectedHostname, b.expectedHostname);
  swap(a.__isset, b.__isset);
}

MatcherHostnameEquals::MatcherHostnameEquals(const MatcherHostnameEquals& other13) {
  expectedHostname = other13.expectedHostname;
  __isset = other13.__isset;
}
MatcherHostnameEquals& MatcherHostnameEquals::operator=(const MatcherHostnameEquals& other14) {
  expectedHostname = other14.expectedHostname;
  __isset = other14.__isset;
  return *this;
}
void MatcherHostnameEquals::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "MatcherHostnameEquals(";
  out << "expectedHostname=" << to_string(expectedHostname);
  out << ")";
}


Matcher::~Matcher() throw() {
}


void Matcher::__set_all(const MatcherAll& val) {
  this->all = val;
}

void Matcher::__set_titleIs(const MatcherTitleIs& val) {
  this->titleIs = val;
}

void Matcher::__set_titleContains(const MatcherTitleContains& val) {
  this->titleContains = val;
}

void Matcher::__set_bodyIs(const MatcherBodyIs& val) {
  this->bodyIs = val;
}

void Matcher::__set_bodyContains(const MatcherBodyContains& val) {
  this->bodyContains = val;
}

void Matcher::__set_urgencyEquals(const MatcherUrgencyEquals& val) {
  this->urgencyEquals = val;
}

void Matcher::__set_hostnameEquals(const MatcherHostnameEquals& val) {
  this->hostnameEquals = val;
}

uint32_t Matcher::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->all.read(iprot);
          this->__isset.all = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->titleIs.read(iprot);
          this->__isset.titleIs = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->titleContains.read(iprot);
          this->__isset.titleContains = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->bodyIs.read(iprot);
          this->__isset.bodyIs = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->bodyContains.read(iprot);
          this->__isset.bodyContains = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->urgencyEquals.read(iprot);
          this->__isset.urgencyEquals = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->hostnameEquals.read(iprot);
          this->__isset.hostnameEquals = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t Matcher::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("Matcher");

  xfer += oprot->writeFieldBegin("all", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->all.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("titleIs", ::apache::thrift::protocol::T_STRUCT, 2);
  xfer += this->titleIs.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("titleContains", ::apache::thrift::protocol::T_STRUCT, 3);
  xfer += this->titleContains.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("bodyIs", ::apache::thrift::protocol::T_STRUCT, 4);
  xfer += this->bodyIs.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("bodyContains", ::apache::thrift::protocol::T_STRUCT, 5);
  xfer += this->bodyContains.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("urgencyEquals", ::apache::thrift::protocol::T_STRUCT, 6);
  xfer += this->urgencyEquals.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("hostnameEquals", ::apache::thrift::protocol::T_STRUCT, 7);
  xfer += this->hostnameEquals.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(Matcher &a, Matcher &b) {
  using ::std::swap;
  swap(a.all, b.all);
  swap(a.titleIs, b.titleIs);
  swap(a.titleContains, b.titleContains);
  swap(a.bodyIs, b.bodyIs);
  swap(a.bodyContains, b.bodyContains);
  swap(a.urgencyEquals, b.urgencyEquals);
  swap(a.hostnameEquals, b.hostnameEquals);
  swap(a.__isset, b.__isset);
}

Matcher::Matcher(const Matcher& other15) {
  all = other15.all;
  titleIs = other15.titleIs;
  titleContains = other15.titleContains;
  bodyIs = other15.bodyIs;
  bodyContains = other15.bodyContains;
  urgencyEquals = other15.urgencyEquals;
  hostnameEquals = other15.hostnameEquals;
  __isset = other15.__isset;
}
Matcher& Matcher::operator=(const Matcher& other16) {
  all = other16.all;
  titleIs = other16.titleIs;
  titleContains = other16.titleContains;
  bodyIs = other16.bodyIs;
  bodyContains = other16.bodyContains;
  urgencyEquals = other16.urgencyEquals;
  hostnameEquals = other16.hostnameEquals;
  __isset = other16.__isset;
  return *this;
}
void Matcher::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "Matcher(";
  out << "all=" << to_string(all);
  out << ", " << "titleIs=" << to_string(titleIs);
  out << ", " << "titleContains=" << to_string(titleContains);
  out << ", " << "bodyIs=" << to_string(bodyIs);
  out << ", " << "bodyContains=" << to_string(bodyContains);
  out << ", " << "urgencyEquals=" << to_string(urgencyEquals);
  out << ", " << "hostnameEquals=" << to_string(hostnameEquals);
  out << ")";
}

}}}} // namespace
