/**
 * Autogenerated by Thrift Compiler (0.9.3)
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *  @generated
 */
#include "Reactions_types.h"

#include <algorithm>
#include <ostream>

#include <thrift/TToString.h>

namespace tech { namespace aroma { namespace thrift { namespace reactions {


MatcherAll::~MatcherAll() throw() {
}


uint32_t MatcherAll::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    xfer += iprot->skip(ftype);
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t MatcherAll::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("MatcherAll");

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(MatcherAll &a, MatcherAll &b) {
  using ::std::swap;
  (void) a;
  (void) b;
}

MatcherAll::MatcherAll(const MatcherAll& other0) {
  (void) other0;
}
MatcherAll& MatcherAll::operator=(const MatcherAll& other1) {
  (void) other1;
  return *this;
}
void MatcherAll::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "MatcherAll(";
  out << ")";
}


MatcherTitleIs::~MatcherTitleIs() throw() {
}


void MatcherTitleIs::__set_expectedTitle(const std::string& val) {
  this->expectedTitle = val;
}

uint32_t MatcherTitleIs::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->expectedTitle);
          this->__isset.expectedTitle = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t MatcherTitleIs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("MatcherTitleIs");

  xfer += oprot->writeFieldBegin("expectedTitle", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->expectedTitle);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(MatcherTitleIs &a, MatcherTitleIs &b) {
  using ::std::swap;
  swap(a.expectedTitle, b.expectedTitle);
  swap(a.__isset, b.__isset);
}

MatcherTitleIs::MatcherTitleIs(const MatcherTitleIs& other2) {
  expectedTitle = other2.expectedTitle;
  __isset = other2.__isset;
}
MatcherTitleIs& MatcherTitleIs::operator=(const MatcherTitleIs& other3) {
  expectedTitle = other3.expectedTitle;
  __isset = other3.__isset;
  return *this;
}
void MatcherTitleIs::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "MatcherTitleIs(";
  out << "expectedTitle=" << to_string(expectedTitle);
  out << ")";
}


MatcherTitleIsNot::~MatcherTitleIsNot() throw() {
}


void MatcherTitleIsNot::__set_title(const std::string& val) {
  this->title = val;
}

uint32_t MatcherTitleIsNot::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->title);
          this->__isset.title = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t MatcherTitleIsNot::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("MatcherTitleIsNot");

  xfer += oprot->writeFieldBegin("title", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->title);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(MatcherTitleIsNot &a, MatcherTitleIsNot &b) {
  using ::std::swap;
  swap(a.title, b.title);
  swap(a.__isset, b.__isset);
}

MatcherTitleIsNot::MatcherTitleIsNot(const MatcherTitleIsNot& other4) {
  title = other4.title;
  __isset = other4.__isset;
}
MatcherTitleIsNot& MatcherTitleIsNot::operator=(const MatcherTitleIsNot& other5) {
  title = other5.title;
  __isset = other5.__isset;
  return *this;
}
void MatcherTitleIsNot::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "MatcherTitleIsNot(";
  out << "title=" << to_string(title);
  out << ")";
}


MatcherTitleContains::~MatcherTitleContains() throw() {
}


void MatcherTitleContains::__set_substring(const std::string& val) {
  this->substring = val;
}

uint32_t MatcherTitleContains::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->substring);
          this->__isset.substring = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t MatcherTitleContains::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("MatcherTitleContains");

  xfer += oprot->writeFieldBegin("substring", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->substring);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(MatcherTitleContains &a, MatcherTitleContains &b) {
  using ::std::swap;
  swap(a.substring, b.substring);
  swap(a.__isset, b.__isset);
}

MatcherTitleContains::MatcherTitleContains(const MatcherTitleContains& other6) {
  substring = other6.substring;
  __isset = other6.__isset;
}
MatcherTitleContains& MatcherTitleContains::operator=(const MatcherTitleContains& other7) {
  substring = other7.substring;
  __isset = other7.__isset;
  return *this;
}
void MatcherTitleContains::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "MatcherTitleContains(";
  out << "substring=" << to_string(substring);
  out << ")";
}


MatcherTitleDoesNotContain::~MatcherTitleDoesNotContain() throw() {
}


void MatcherTitleDoesNotContain::__set_substring(const std::string& val) {
  this->substring = val;
}

uint32_t MatcherTitleDoesNotContain::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->substring);
          this->__isset.substring = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t MatcherTitleDoesNotContain::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("MatcherTitleDoesNotContain");

  xfer += oprot->writeFieldBegin("substring", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->substring);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(MatcherTitleDoesNotContain &a, MatcherTitleDoesNotContain &b) {
  using ::std::swap;
  swap(a.substring, b.substring);
  swap(a.__isset, b.__isset);
}

MatcherTitleDoesNotContain::MatcherTitleDoesNotContain(const MatcherTitleDoesNotContain& other8) {
  substring = other8.substring;
  __isset = other8.__isset;
}
MatcherTitleDoesNotContain& MatcherTitleDoesNotContain::operator=(const MatcherTitleDoesNotContain& other9) {
  substring = other9.substring;
  __isset = other9.__isset;
  return *this;
}
void MatcherTitleDoesNotContain::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "MatcherTitleDoesNotContain(";
  out << "substring=" << to_string(substring);
  out << ")";
}


MatcherBodyIs::~MatcherBodyIs() throw() {
}


void MatcherBodyIs::__set_expectedBody(const std::string& val) {
  this->expectedBody = val;
}

uint32_t MatcherBodyIs::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->expectedBody);
          this->__isset.expectedBody = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t MatcherBodyIs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("MatcherBodyIs");

  xfer += oprot->writeFieldBegin("expectedBody", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->expectedBody);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(MatcherBodyIs &a, MatcherBodyIs &b) {
  using ::std::swap;
  swap(a.expectedBody, b.expectedBody);
  swap(a.__isset, b.__isset);
}

MatcherBodyIs::MatcherBodyIs(const MatcherBodyIs& other10) {
  expectedBody = other10.expectedBody;
  __isset = other10.__isset;
}
MatcherBodyIs& MatcherBodyIs::operator=(const MatcherBodyIs& other11) {
  expectedBody = other11.expectedBody;
  __isset = other11.__isset;
  return *this;
}
void MatcherBodyIs::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "MatcherBodyIs(";
  out << "expectedBody=" << to_string(expectedBody);
  out << ")";
}


MatcherBodyContains::~MatcherBodyContains() throw() {
}


void MatcherBodyContains::__set_substring(const std::string& val) {
  this->substring = val;
}

uint32_t MatcherBodyContains::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->substring);
          this->__isset.substring = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t MatcherBodyContains::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("MatcherBodyContains");

  xfer += oprot->writeFieldBegin("substring", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->substring);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(MatcherBodyContains &a, MatcherBodyContains &b) {
  using ::std::swap;
  swap(a.substring, b.substring);
  swap(a.__isset, b.__isset);
}

MatcherBodyContains::MatcherBodyContains(const MatcherBodyContains& other12) {
  substring = other12.substring;
  __isset = other12.__isset;
}
MatcherBodyContains& MatcherBodyContains::operator=(const MatcherBodyContains& other13) {
  substring = other13.substring;
  __isset = other13.__isset;
  return *this;
}
void MatcherBodyContains::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "MatcherBodyContains(";
  out << "substring=" << to_string(substring);
  out << ")";
}


MatcherBodyDoesNotContain::~MatcherBodyDoesNotContain() throw() {
}


void MatcherBodyDoesNotContain::__set_substring(const std::string& val) {
  this->substring = val;
}

uint32_t MatcherBodyDoesNotContain::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->substring);
          this->__isset.substring = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t MatcherBodyDoesNotContain::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("MatcherBodyDoesNotContain");

  xfer += oprot->writeFieldBegin("substring", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->substring);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(MatcherBodyDoesNotContain &a, MatcherBodyDoesNotContain &b) {
  using ::std::swap;
  swap(a.substring, b.substring);
  swap(a.__isset, b.__isset);
}

MatcherBodyDoesNotContain::MatcherBodyDoesNotContain(const MatcherBodyDoesNotContain& other14) {
  substring = other14.substring;
  __isset = other14.__isset;
}
MatcherBodyDoesNotContain& MatcherBodyDoesNotContain::operator=(const MatcherBodyDoesNotContain& other15) {
  substring = other15.substring;
  __isset = other15.__isset;
  return *this;
}
void MatcherBodyDoesNotContain::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "MatcherBodyDoesNotContain(";
  out << "substring=" << to_string(substring);
  out << ")";
}


MatcherUrgencyIs::~MatcherUrgencyIs() throw() {
}


void MatcherUrgencyIs::__set_possibleUrgencies(const std::set< ::tech::aroma::thrift::Urgency::type> & val) {
  this->possibleUrgencies = val;
}

uint32_t MatcherUrgencyIs::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_SET) {
          {
            this->possibleUrgencies.clear();
            uint32_t _size16;
            ::apache::thrift::protocol::TType _etype19;
            xfer += iprot->readSetBegin(_etype19, _size16);
            uint32_t _i20;
            for (_i20 = 0; _i20 < _size16; ++_i20)
            {
               ::tech::aroma::thrift::Urgency::type _elem21;
              int32_t ecast22;
              xfer += iprot->readI32(ecast22);
              _elem21 = ( ::tech::aroma::thrift::Urgency::type)ecast22;
              this->possibleUrgencies.insert(_elem21);
            }
            xfer += iprot->readSetEnd();
          }
          this->__isset.possibleUrgencies = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t MatcherUrgencyIs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("MatcherUrgencyIs");

  xfer += oprot->writeFieldBegin("possibleUrgencies", ::apache::thrift::protocol::T_SET, 1);
  {
    xfer += oprot->writeSetBegin(::apache::thrift::protocol::T_I32, static_cast<uint32_t>(this->possibleUrgencies.size()));
    std::set< ::tech::aroma::thrift::Urgency::type> ::const_iterator _iter23;
    for (_iter23 = this->possibleUrgencies.begin(); _iter23 != this->possibleUrgencies.end(); ++_iter23)
    {
      xfer += oprot->writeI32((int32_t)(*_iter23));
    }
    xfer += oprot->writeSetEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(MatcherUrgencyIs &a, MatcherUrgencyIs &b) {
  using ::std::swap;
  swap(a.possibleUrgencies, b.possibleUrgencies);
  swap(a.__isset, b.__isset);
}

MatcherUrgencyIs::MatcherUrgencyIs(const MatcherUrgencyIs& other24) {
  possibleUrgencies = other24.possibleUrgencies;
  __isset = other24.__isset;
}
MatcherUrgencyIs& MatcherUrgencyIs::operator=(const MatcherUrgencyIs& other25) {
  possibleUrgencies = other25.possibleUrgencies;
  __isset = other25.__isset;
  return *this;
}
void MatcherUrgencyIs::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "MatcherUrgencyIs(";
  out << "possibleUrgencies=" << to_string(possibleUrgencies);
  out << ")";
}


MatcherHostnameIs::~MatcherHostnameIs() throw() {
}


void MatcherHostnameIs::__set_expectedHostname(const std::string& val) {
  this->expectedHostname = val;
}

uint32_t MatcherHostnameIs::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->expectedHostname);
          this->__isset.expectedHostname = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t MatcherHostnameIs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("MatcherHostnameIs");

  xfer += oprot->writeFieldBegin("expectedHostname", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->expectedHostname);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(MatcherHostnameIs &a, MatcherHostnameIs &b) {
  using ::std::swap;
  swap(a.expectedHostname, b.expectedHostname);
  swap(a.__isset, b.__isset);
}

MatcherHostnameIs::MatcherHostnameIs(const MatcherHostnameIs& other26) {
  expectedHostname = other26.expectedHostname;
  __isset = other26.__isset;
}
MatcherHostnameIs& MatcherHostnameIs::operator=(const MatcherHostnameIs& other27) {
  expectedHostname = other27.expectedHostname;
  __isset = other27.__isset;
  return *this;
}
void MatcherHostnameIs::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "MatcherHostnameIs(";
  out << "expectedHostname=" << to_string(expectedHostname);
  out << ")";
}


MatcherHostnameContains::~MatcherHostnameContains() throw() {
}


void MatcherHostnameContains::__set_substring(const std::string& val) {
  this->substring = val;
}

uint32_t MatcherHostnameContains::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->substring);
          this->__isset.substring = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t MatcherHostnameContains::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("MatcherHostnameContains");

  xfer += oprot->writeFieldBegin("substring", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->substring);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(MatcherHostnameContains &a, MatcherHostnameContains &b) {
  using ::std::swap;
  swap(a.substring, b.substring);
  swap(a.__isset, b.__isset);
}

MatcherHostnameContains::MatcherHostnameContains(const MatcherHostnameContains& other28) {
  substring = other28.substring;
  __isset = other28.__isset;
}
MatcherHostnameContains& MatcherHostnameContains::operator=(const MatcherHostnameContains& other29) {
  substring = other29.substring;
  __isset = other29.__isset;
  return *this;
}
void MatcherHostnameContains::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "MatcherHostnameContains(";
  out << "substring=" << to_string(substring);
  out << ")";
}


MatcherHostnameDoesNotContain::~MatcherHostnameDoesNotContain() throw() {
}


void MatcherHostnameDoesNotContain::__set_substring(const std::string& val) {
  this->substring = val;
}

uint32_t MatcherHostnameDoesNotContain::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->substring);
          this->__isset.substring = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t MatcherHostnameDoesNotContain::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("MatcherHostnameDoesNotContain");

  xfer += oprot->writeFieldBegin("substring", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->substring);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(MatcherHostnameDoesNotContain &a, MatcherHostnameDoesNotContain &b) {
  using ::std::swap;
  swap(a.substring, b.substring);
  swap(a.__isset, b.__isset);
}

MatcherHostnameDoesNotContain::MatcherHostnameDoesNotContain(const MatcherHostnameDoesNotContain& other30) {
  substring = other30.substring;
  __isset = other30.__isset;
}
MatcherHostnameDoesNotContain& MatcherHostnameDoesNotContain::operator=(const MatcherHostnameDoesNotContain& other31) {
  substring = other31.substring;
  __isset = other31.__isset;
  return *this;
}
void MatcherHostnameDoesNotContain::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "MatcherHostnameDoesNotContain(";
  out << "substring=" << to_string(substring);
  out << ")";
}


MatcherApplicationIs::~MatcherApplicationIs() throw() {
}


void MatcherApplicationIs::__set_appId(const uuid& val) {
  this->appId = val;
}

uint32_t MatcherApplicationIs::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->appId);
          this->__isset.appId = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t MatcherApplicationIs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("MatcherApplicationIs");

  xfer += oprot->writeFieldBegin("appId", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->appId);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(MatcherApplicationIs &a, MatcherApplicationIs &b) {
  using ::std::swap;
  swap(a.appId, b.appId);
  swap(a.__isset, b.__isset);
}

MatcherApplicationIs::MatcherApplicationIs(const MatcherApplicationIs& other32) {
  appId = other32.appId;
  __isset = other32.__isset;
}
MatcherApplicationIs& MatcherApplicationIs::operator=(const MatcherApplicationIs& other33) {
  appId = other33.appId;
  __isset = other33.__isset;
  return *this;
}
void MatcherApplicationIs::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "MatcherApplicationIs(";
  out << "appId=" << to_string(appId);
  out << ")";
}


MatcherApplicationIsNot::~MatcherApplicationIsNot() throw() {
}


void MatcherApplicationIsNot::__set_appId(const uuid& val) {
  this->appId = val;
}

uint32_t MatcherApplicationIsNot::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->appId);
          this->__isset.appId = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t MatcherApplicationIsNot::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("MatcherApplicationIsNot");

  xfer += oprot->writeFieldBegin("appId", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->appId);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(MatcherApplicationIsNot &a, MatcherApplicationIsNot &b) {
  using ::std::swap;
  swap(a.appId, b.appId);
  swap(a.__isset, b.__isset);
}

MatcherApplicationIsNot::MatcherApplicationIsNot(const MatcherApplicationIsNot& other34) {
  appId = other34.appId;
  __isset = other34.__isset;
}
MatcherApplicationIsNot& MatcherApplicationIsNot::operator=(const MatcherApplicationIsNot& other35) {
  appId = other35.appId;
  __isset = other35.__isset;
  return *this;
}
void MatcherApplicationIsNot::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "MatcherApplicationIsNot(";
  out << "appId=" << to_string(appId);
  out << ")";
}


AromaMatcher::~AromaMatcher() throw() {
}


void AromaMatcher::__set_all(const MatcherAll& val) {
  this->all = val;
}

void AromaMatcher::__set_titleIs(const MatcherTitleIs& val) {
  this->titleIs = val;
}

void AromaMatcher::__set_titleIsNot(const MatcherTitleIsNot& val) {
  this->titleIsNot = val;
}

void AromaMatcher::__set_titleContains(const MatcherTitleContains& val) {
  this->titleContains = val;
}

void AromaMatcher::__set_titleDoesNotContain(const MatcherTitleDoesNotContain& val) {
  this->titleDoesNotContain = val;
}

void AromaMatcher::__set_bodyIs(const MatcherBodyIs& val) {
  this->bodyIs = val;
}

void AromaMatcher::__set_bodyContains(const MatcherBodyContains& val) {
  this->bodyContains = val;
}

void AromaMatcher::__set_bodyDoesNotContain(const MatcherBodyDoesNotContain& val) {
  this->bodyDoesNotContain = val;
}

void AromaMatcher::__set_urgencyEquals(const MatcherUrgencyIs& val) {
  this->urgencyEquals = val;
}

void AromaMatcher::__set_hostnameIs(const MatcherHostnameIs& val) {
  this->hostnameIs = val;
}

void AromaMatcher::__set_hostnameContains(const MatcherHostnameContains& val) {
  this->hostnameContains = val;
}

void AromaMatcher::__set_hostnameDoesNotContain(const MatcherHostnameDoesNotContain& val) {
  this->hostnameDoesNotContain = val;
}

void AromaMatcher::__set_applicationIs(const MatcherApplicationIs& val) {
  this->applicationIs = val;
}

void AromaMatcher::__set_applicationIsNot(const MatcherApplicationIsNot& val) {
  this->applicationIsNot = val;
}

uint32_t AromaMatcher::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->all.read(iprot);
          this->__isset.all = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->titleIs.read(iprot);
          this->__isset.titleIs = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->titleIsNot.read(iprot);
          this->__isset.titleIsNot = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->titleContains.read(iprot);
          this->__isset.titleContains = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->titleDoesNotContain.read(iprot);
          this->__isset.titleDoesNotContain = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->bodyIs.read(iprot);
          this->__isset.bodyIs = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->bodyContains.read(iprot);
          this->__isset.bodyContains = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 8:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->bodyDoesNotContain.read(iprot);
          this->__isset.bodyDoesNotContain = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 9:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->urgencyEquals.read(iprot);
          this->__isset.urgencyEquals = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 10:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->hostnameIs.read(iprot);
          this->__isset.hostnameIs = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 11:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->hostnameContains.read(iprot);
          this->__isset.hostnameContains = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 12:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->hostnameDoesNotContain.read(iprot);
          this->__isset.hostnameDoesNotContain = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 13:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->applicationIs.read(iprot);
          this->__isset.applicationIs = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 14:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->applicationIsNot.read(iprot);
          this->__isset.applicationIsNot = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t AromaMatcher::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("AromaMatcher");

  xfer += oprot->writeFieldBegin("all", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->all.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("titleIs", ::apache::thrift::protocol::T_STRUCT, 2);
  xfer += this->titleIs.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("titleIsNot", ::apache::thrift::protocol::T_STRUCT, 3);
  xfer += this->titleIsNot.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("titleContains", ::apache::thrift::protocol::T_STRUCT, 4);
  xfer += this->titleContains.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("titleDoesNotContain", ::apache::thrift::protocol::T_STRUCT, 5);
  xfer += this->titleDoesNotContain.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("bodyIs", ::apache::thrift::protocol::T_STRUCT, 6);
  xfer += this->bodyIs.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("bodyContains", ::apache::thrift::protocol::T_STRUCT, 7);
  xfer += this->bodyContains.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("bodyDoesNotContain", ::apache::thrift::protocol::T_STRUCT, 8);
  xfer += this->bodyDoesNotContain.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("urgencyEquals", ::apache::thrift::protocol::T_STRUCT, 9);
  xfer += this->urgencyEquals.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("hostnameIs", ::apache::thrift::protocol::T_STRUCT, 10);
  xfer += this->hostnameIs.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("hostnameContains", ::apache::thrift::protocol::T_STRUCT, 11);
  xfer += this->hostnameContains.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("hostnameDoesNotContain", ::apache::thrift::protocol::T_STRUCT, 12);
  xfer += this->hostnameDoesNotContain.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("applicationIs", ::apache::thrift::protocol::T_STRUCT, 13);
  xfer += this->applicationIs.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("applicationIsNot", ::apache::thrift::protocol::T_STRUCT, 14);
  xfer += this->applicationIsNot.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(AromaMatcher &a, AromaMatcher &b) {
  using ::std::swap;
  swap(a.all, b.all);
  swap(a.titleIs, b.titleIs);
  swap(a.titleIsNot, b.titleIsNot);
  swap(a.titleContains, b.titleContains);
  swap(a.titleDoesNotContain, b.titleDoesNotContain);
  swap(a.bodyIs, b.bodyIs);
  swap(a.bodyContains, b.bodyContains);
  swap(a.bodyDoesNotContain, b.bodyDoesNotContain);
  swap(a.urgencyEquals, b.urgencyEquals);
  swap(a.hostnameIs, b.hostnameIs);
  swap(a.hostnameContains, b.hostnameContains);
  swap(a.hostnameDoesNotContain, b.hostnameDoesNotContain);
  swap(a.applicationIs, b.applicationIs);
  swap(a.applicationIsNot, b.applicationIsNot);
  swap(a.__isset, b.__isset);
}

AromaMatcher::AromaMatcher(const AromaMatcher& other36) {
  all = other36.all;
  titleIs = other36.titleIs;
  titleIsNot = other36.titleIsNot;
  titleContains = other36.titleContains;
  titleDoesNotContain = other36.titleDoesNotContain;
  bodyIs = other36.bodyIs;
  bodyContains = other36.bodyContains;
  bodyDoesNotContain = other36.bodyDoesNotContain;
  urgencyEquals = other36.urgencyEquals;
  hostnameIs = other36.hostnameIs;
  hostnameContains = other36.hostnameContains;
  hostnameDoesNotContain = other36.hostnameDoesNotContain;
  applicationIs = other36.applicationIs;
  applicationIsNot = other36.applicationIsNot;
  __isset = other36.__isset;
}
AromaMatcher& AromaMatcher::operator=(const AromaMatcher& other37) {
  all = other37.all;
  titleIs = other37.titleIs;
  titleIsNot = other37.titleIsNot;
  titleContains = other37.titleContains;
  titleDoesNotContain = other37.titleDoesNotContain;
  bodyIs = other37.bodyIs;
  bodyContains = other37.bodyContains;
  bodyDoesNotContain = other37.bodyDoesNotContain;
  urgencyEquals = other37.urgencyEquals;
  hostnameIs = other37.hostnameIs;
  hostnameContains = other37.hostnameContains;
  hostnameDoesNotContain = other37.hostnameDoesNotContain;
  applicationIs = other37.applicationIs;
  applicationIsNot = other37.applicationIsNot;
  __isset = other37.__isset;
  return *this;
}
void AromaMatcher::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "AromaMatcher(";
  out << "all=" << to_string(all);
  out << ", " << "titleIs=" << to_string(titleIs);
  out << ", " << "titleIsNot=" << to_string(titleIsNot);
  out << ", " << "titleContains=" << to_string(titleContains);
  out << ", " << "titleDoesNotContain=" << to_string(titleDoesNotContain);
  out << ", " << "bodyIs=" << to_string(bodyIs);
  out << ", " << "bodyContains=" << to_string(bodyContains);
  out << ", " << "bodyDoesNotContain=" << to_string(bodyDoesNotContain);
  out << ", " << "urgencyEquals=" << to_string(urgencyEquals);
  out << ", " << "hostnameIs=" << to_string(hostnameIs);
  out << ", " << "hostnameContains=" << to_string(hostnameContains);
  out << ", " << "hostnameDoesNotContain=" << to_string(hostnameDoesNotContain);
  out << ", " << "applicationIs=" << to_string(applicationIs);
  out << ", " << "applicationIsNot=" << to_string(applicationIsNot);
  out << ")";
}


ActionForwardToSlackChannel::~ActionForwardToSlackChannel() throw() {
}


void ActionForwardToSlackChannel::__set_slackChannel(const std::string& val) {
  this->slackChannel = val;
}

void ActionForwardToSlackChannel::__set_includeBody(const bool val) {
  this->includeBody = val;
__isset.includeBody = true;
}

void ActionForwardToSlackChannel::__set_webhookUrl(const std::string& val) {
  this->webhookUrl = val;
}

void ActionForwardToSlackChannel::__set_domainName(const std::string& val) {
  this->domainName = val;
__isset.domainName = true;
}

uint32_t ActionForwardToSlackChannel::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->slackChannel);
          this->__isset.slackChannel = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->includeBody);
          this->__isset.includeBody = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->webhookUrl);
          this->__isset.webhookUrl = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->domainName);
          this->__isset.domainName = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t ActionForwardToSlackChannel::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("ActionForwardToSlackChannel");

  xfer += oprot->writeFieldBegin("slackChannel", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->slackChannel);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.includeBody) {
    xfer += oprot->writeFieldBegin("includeBody", ::apache::thrift::protocol::T_BOOL, 2);
    xfer += oprot->writeBool(this->includeBody);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldBegin("webhookUrl", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeString(this->webhookUrl);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.domainName) {
    xfer += oprot->writeFieldBegin("domainName", ::apache::thrift::protocol::T_STRING, 4);
    xfer += oprot->writeString(this->domainName);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(ActionForwardToSlackChannel &a, ActionForwardToSlackChannel &b) {
  using ::std::swap;
  swap(a.slackChannel, b.slackChannel);
  swap(a.includeBody, b.includeBody);
  swap(a.webhookUrl, b.webhookUrl);
  swap(a.domainName, b.domainName);
  swap(a.__isset, b.__isset);
}

ActionForwardToSlackChannel::ActionForwardToSlackChannel(const ActionForwardToSlackChannel& other38) {
  slackChannel = other38.slackChannel;
  includeBody = other38.includeBody;
  webhookUrl = other38.webhookUrl;
  domainName = other38.domainName;
  __isset = other38.__isset;
}
ActionForwardToSlackChannel& ActionForwardToSlackChannel::operator=(const ActionForwardToSlackChannel& other39) {
  slackChannel = other39.slackChannel;
  includeBody = other39.includeBody;
  webhookUrl = other39.webhookUrl;
  domainName = other39.domainName;
  __isset = other39.__isset;
  return *this;
}
void ActionForwardToSlackChannel::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "ActionForwardToSlackChannel(";
  out << "slackChannel=" << to_string(slackChannel);
  out << ", " << "includeBody="; (__isset.includeBody ? (out << to_string(includeBody)) : (out << "<null>"));
  out << ", " << "webhookUrl=" << to_string(webhookUrl);
  out << ", " << "domainName="; (__isset.domainName ? (out << to_string(domainName)) : (out << "<null>"));
  out << ")";
}


ActionForwardToSlackUser::~ActionForwardToSlackUser() throw() {
}


void ActionForwardToSlackUser::__set_slackUsername(const std::string& val) {
  this->slackUsername = val;
}

void ActionForwardToSlackUser::__set_includeBody(const bool val) {
  this->includeBody = val;
__isset.includeBody = true;
}

void ActionForwardToSlackUser::__set_webhookUrl(const std::string& val) {
  this->webhookUrl = val;
}

void ActionForwardToSlackUser::__set_domainName(const std::string& val) {
  this->domainName = val;
__isset.domainName = true;
}

uint32_t ActionForwardToSlackUser::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->slackUsername);
          this->__isset.slackUsername = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->includeBody);
          this->__isset.includeBody = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->webhookUrl);
          this->__isset.webhookUrl = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->domainName);
          this->__isset.domainName = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t ActionForwardToSlackUser::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("ActionForwardToSlackUser");

  xfer += oprot->writeFieldBegin("slackUsername", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->slackUsername);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.includeBody) {
    xfer += oprot->writeFieldBegin("includeBody", ::apache::thrift::protocol::T_BOOL, 2);
    xfer += oprot->writeBool(this->includeBody);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldBegin("webhookUrl", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeString(this->webhookUrl);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.domainName) {
    xfer += oprot->writeFieldBegin("domainName", ::apache::thrift::protocol::T_STRING, 4);
    xfer += oprot->writeString(this->domainName);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(ActionForwardToSlackUser &a, ActionForwardToSlackUser &b) {
  using ::std::swap;
  swap(a.slackUsername, b.slackUsername);
  swap(a.includeBody, b.includeBody);
  swap(a.webhookUrl, b.webhookUrl);
  swap(a.domainName, b.domainName);
  swap(a.__isset, b.__isset);
}

ActionForwardToSlackUser::ActionForwardToSlackUser(const ActionForwardToSlackUser& other40) {
  slackUsername = other40.slackUsername;
  includeBody = other40.includeBody;
  webhookUrl = other40.webhookUrl;
  domainName = other40.domainName;
  __isset = other40.__isset;
}
ActionForwardToSlackUser& ActionForwardToSlackUser::operator=(const ActionForwardToSlackUser& other41) {
  slackUsername = other41.slackUsername;
  includeBody = other41.includeBody;
  webhookUrl = other41.webhookUrl;
  domainName = other41.domainName;
  __isset = other41.__isset;
  return *this;
}
void ActionForwardToSlackUser::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "ActionForwardToSlackUser(";
  out << "slackUsername=" << to_string(slackUsername);
  out << ", " << "includeBody="; (__isset.includeBody ? (out << to_string(includeBody)) : (out << "<null>"));
  out << ", " << "webhookUrl=" << to_string(webhookUrl);
  out << ", " << "domainName="; (__isset.domainName ? (out << to_string(domainName)) : (out << "<null>"));
  out << ")";
}


ActionSendEmail::~ActionSendEmail() throw() {
}


void ActionSendEmail::__set_emailAddress(const std::string& val) {
  this->emailAddress = val;
}

void ActionSendEmail::__set_includeBody(const bool val) {
  this->includeBody = val;
__isset.includeBody = true;
}

uint32_t ActionSendEmail::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->emailAddress);
          this->__isset.emailAddress = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->includeBody);
          this->__isset.includeBody = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t ActionSendEmail::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("ActionSendEmail");

  xfer += oprot->writeFieldBegin("emailAddress", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->emailAddress);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.includeBody) {
    xfer += oprot->writeFieldBegin("includeBody", ::apache::thrift::protocol::T_BOOL, 2);
    xfer += oprot->writeBool(this->includeBody);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(ActionSendEmail &a, ActionSendEmail &b) {
  using ::std::swap;
  swap(a.emailAddress, b.emailAddress);
  swap(a.includeBody, b.includeBody);
  swap(a.__isset, b.__isset);
}

ActionSendEmail::ActionSendEmail(const ActionSendEmail& other42) {
  emailAddress = other42.emailAddress;
  includeBody = other42.includeBody;
  __isset = other42.__isset;
}
ActionSendEmail& ActionSendEmail::operator=(const ActionSendEmail& other43) {
  emailAddress = other43.emailAddress;
  includeBody = other43.includeBody;
  __isset = other43.__isset;
  return *this;
}
void ActionSendEmail::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "ActionSendEmail(";
  out << "emailAddress=" << to_string(emailAddress);
  out << ", " << "includeBody="; (__isset.includeBody ? (out << to_string(includeBody)) : (out << "<null>"));
  out << ")";
}


ActionSkipInbox::~ActionSkipInbox() throw() {
}


uint32_t ActionSkipInbox::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    xfer += iprot->skip(ftype);
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t ActionSkipInbox::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("ActionSkipInbox");

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(ActionSkipInbox &a, ActionSkipInbox &b) {
  using ::std::swap;
  (void) a;
  (void) b;
}

ActionSkipInbox::ActionSkipInbox(const ActionSkipInbox& other44) {
  (void) other44;
}
ActionSkipInbox& ActionSkipInbox::operator=(const ActionSkipInbox& other45) {
  (void) other45;
  return *this;
}
void ActionSkipInbox::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "ActionSkipInbox(";
  out << ")";
}


ActionDontStoreMessage::~ActionDontStoreMessage() throw() {
}


uint32_t ActionDontStoreMessage::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    xfer += iprot->skip(ftype);
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t ActionDontStoreMessage::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("ActionDontStoreMessage");

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(ActionDontStoreMessage &a, ActionDontStoreMessage &b) {
  using ::std::swap;
  (void) a;
  (void) b;
}

ActionDontStoreMessage::ActionDontStoreMessage(const ActionDontStoreMessage& other46) {
  (void) other46;
}
ActionDontStoreMessage& ActionDontStoreMessage::operator=(const ActionDontStoreMessage& other47) {
  (void) other47;
  return *this;
}
void ActionDontStoreMessage::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "ActionDontStoreMessage(";
  out << ")";
}


ActionRespondWithMessage::~ActionRespondWithMessage() throw() {
}


void ActionRespondWithMessage::__set_messageToRespondWith(const std::string& val) {
  this->messageToRespondWith = val;
}

uint32_t ActionRespondWithMessage::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->messageToRespondWith);
          this->__isset.messageToRespondWith = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t ActionRespondWithMessage::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("ActionRespondWithMessage");

  xfer += oprot->writeFieldBegin("messageToRespondWith", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->messageToRespondWith);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(ActionRespondWithMessage &a, ActionRespondWithMessage &b) {
  using ::std::swap;
  swap(a.messageToRespondWith, b.messageToRespondWith);
  swap(a.__isset, b.__isset);
}

ActionRespondWithMessage::ActionRespondWithMessage(const ActionRespondWithMessage& other48) {
  messageToRespondWith = other48.messageToRespondWith;
  __isset = other48.__isset;
}
ActionRespondWithMessage& ActionRespondWithMessage::operator=(const ActionRespondWithMessage& other49) {
  messageToRespondWith = other49.messageToRespondWith;
  __isset = other49.__isset;
  return *this;
}
void ActionRespondWithMessage::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "ActionRespondWithMessage(";
  out << "messageToRespondWith=" << to_string(messageToRespondWith);
  out << ")";
}


ActionForwardToUsers::~ActionForwardToUsers() throw() {
}


void ActionForwardToUsers::__set_userIds(const std::vector<uuid> & val) {
  this->userIds = val;
}

uint32_t ActionForwardToUsers::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->userIds.clear();
            uint32_t _size50;
            ::apache::thrift::protocol::TType _etype53;
            xfer += iprot->readListBegin(_etype53, _size50);
            this->userIds.resize(_size50);
            uint32_t _i54;
            for (_i54 = 0; _i54 < _size50; ++_i54)
            {
              xfer += iprot->readString(this->userIds[_i54]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.userIds = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t ActionForwardToUsers::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("ActionForwardToUsers");

  xfer += oprot->writeFieldBegin("userIds", ::apache::thrift::protocol::T_LIST, 1);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->userIds.size()));
    std::vector<uuid> ::const_iterator _iter55;
    for (_iter55 = this->userIds.begin(); _iter55 != this->userIds.end(); ++_iter55)
    {
      xfer += oprot->writeString((*_iter55));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(ActionForwardToUsers &a, ActionForwardToUsers &b) {
  using ::std::swap;
  swap(a.userIds, b.userIds);
  swap(a.__isset, b.__isset);
}

ActionForwardToUsers::ActionForwardToUsers(const ActionForwardToUsers& other56) {
  userIds = other56.userIds;
  __isset = other56.__isset;
}
ActionForwardToUsers& ActionForwardToUsers::operator=(const ActionForwardToUsers& other57) {
  userIds = other57.userIds;
  __isset = other57.__isset;
  return *this;
}
void ActionForwardToUsers::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "ActionForwardToUsers(";
  out << "userIds=" << to_string(userIds);
  out << ")";
}


AromaAction::~AromaAction() throw() {
}


void AromaAction::__set_forwardToSlackChannel(const ActionForwardToSlackChannel& val) {
  this->forwardToSlackChannel = val;
}

void AromaAction::__set_forwardToSlackUser(const ActionForwardToSlackUser& val) {
  this->forwardToSlackUser = val;
}

void AromaAction::__set_sendEmail(const ActionSendEmail& val) {
  this->sendEmail = val;
}

void AromaAction::__set_skipInbox(const ActionSkipInbox& val) {
  this->skipInbox = val;
}

void AromaAction::__set_dontStoreMessage(const ActionDontStoreMessage& val) {
  this->dontStoreMessage = val;
}

void AromaAction::__set_responseWithMessage(const ActionRespondWithMessage& val) {
  this->responseWithMessage = val;
}

void AromaAction::__set_forwardToUsers(const ActionForwardToUsers& val) {
  this->forwardToUsers = val;
}

uint32_t AromaAction::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->forwardToSlackChannel.read(iprot);
          this->__isset.forwardToSlackChannel = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->forwardToSlackUser.read(iprot);
          this->__isset.forwardToSlackUser = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->sendEmail.read(iprot);
          this->__isset.sendEmail = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->skipInbox.read(iprot);
          this->__isset.skipInbox = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->dontStoreMessage.read(iprot);
          this->__isset.dontStoreMessage = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->responseWithMessage.read(iprot);
          this->__isset.responseWithMessage = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->forwardToUsers.read(iprot);
          this->__isset.forwardToUsers = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t AromaAction::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("AromaAction");

  xfer += oprot->writeFieldBegin("forwardToSlackChannel", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->forwardToSlackChannel.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("forwardToSlackUser", ::apache::thrift::protocol::T_STRUCT, 2);
  xfer += this->forwardToSlackUser.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("sendEmail", ::apache::thrift::protocol::T_STRUCT, 3);
  xfer += this->sendEmail.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("skipInbox", ::apache::thrift::protocol::T_STRUCT, 4);
  xfer += this->skipInbox.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("dontStoreMessage", ::apache::thrift::protocol::T_STRUCT, 5);
  xfer += this->dontStoreMessage.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("responseWithMessage", ::apache::thrift::protocol::T_STRUCT, 6);
  xfer += this->responseWithMessage.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("forwardToUsers", ::apache::thrift::protocol::T_STRUCT, 7);
  xfer += this->forwardToUsers.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(AromaAction &a, AromaAction &b) {
  using ::std::swap;
  swap(a.forwardToSlackChannel, b.forwardToSlackChannel);
  swap(a.forwardToSlackUser, b.forwardToSlackUser);
  swap(a.sendEmail, b.sendEmail);
  swap(a.skipInbox, b.skipInbox);
  swap(a.dontStoreMessage, b.dontStoreMessage);
  swap(a.responseWithMessage, b.responseWithMessage);
  swap(a.forwardToUsers, b.forwardToUsers);
  swap(a.__isset, b.__isset);
}

AromaAction::AromaAction(const AromaAction& other58) {
  forwardToSlackChannel = other58.forwardToSlackChannel;
  forwardToSlackUser = other58.forwardToSlackUser;
  sendEmail = other58.sendEmail;
  skipInbox = other58.skipInbox;
  dontStoreMessage = other58.dontStoreMessage;
  responseWithMessage = other58.responseWithMessage;
  forwardToUsers = other58.forwardToUsers;
  __isset = other58.__isset;
}
AromaAction& AromaAction::operator=(const AromaAction& other59) {
  forwardToSlackChannel = other59.forwardToSlackChannel;
  forwardToSlackUser = other59.forwardToSlackUser;
  sendEmail = other59.sendEmail;
  skipInbox = other59.skipInbox;
  dontStoreMessage = other59.dontStoreMessage;
  responseWithMessage = other59.responseWithMessage;
  forwardToUsers = other59.forwardToUsers;
  __isset = other59.__isset;
  return *this;
}
void AromaAction::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "AromaAction(";
  out << "forwardToSlackChannel=" << to_string(forwardToSlackChannel);
  out << ", " << "forwardToSlackUser=" << to_string(forwardToSlackUser);
  out << ", " << "sendEmail=" << to_string(sendEmail);
  out << ", " << "skipInbox=" << to_string(skipInbox);
  out << ", " << "dontStoreMessage=" << to_string(dontStoreMessage);
  out << ", " << "responseWithMessage=" << to_string(responseWithMessage);
  out << ", " << "forwardToUsers=" << to_string(forwardToUsers);
  out << ")";
}


Reaction::~Reaction() throw() {
}


void Reaction::__set_matchers(const std::vector<AromaMatcher> & val) {
  this->matchers = val;
}

void Reaction::__set_actions(const std::vector<AromaAction> & val) {
  this->actions = val;
}

void Reaction::__set_name(const std::string& val) {
  this->name = val;
}

uint32_t Reaction::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->matchers.clear();
            uint32_t _size60;
            ::apache::thrift::protocol::TType _etype63;
            xfer += iprot->readListBegin(_etype63, _size60);
            this->matchers.resize(_size60);
            uint32_t _i64;
            for (_i64 = 0; _i64 < _size60; ++_i64)
            {
              xfer += this->matchers[_i64].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.matchers = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->actions.clear();
            uint32_t _size65;
            ::apache::thrift::protocol::TType _etype68;
            xfer += iprot->readListBegin(_etype68, _size65);
            this->actions.resize(_size65);
            uint32_t _i69;
            for (_i69 = 0; _i69 < _size65; ++_i69)
            {
              xfer += this->actions[_i69].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.actions = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->name);
          this->__isset.name = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t Reaction::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("Reaction");

  xfer += oprot->writeFieldBegin("matchers", ::apache::thrift::protocol::T_LIST, 1);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->matchers.size()));
    std::vector<AromaMatcher> ::const_iterator _iter70;
    for (_iter70 = this->matchers.begin(); _iter70 != this->matchers.end(); ++_iter70)
    {
      xfer += (*_iter70).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("actions", ::apache::thrift::protocol::T_LIST, 2);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->actions.size()));
    std::vector<AromaAction> ::const_iterator _iter71;
    for (_iter71 = this->actions.begin(); _iter71 != this->actions.end(); ++_iter71)
    {
      xfer += (*_iter71).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("name", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeString(this->name);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(Reaction &a, Reaction &b) {
  using ::std::swap;
  swap(a.matchers, b.matchers);
  swap(a.actions, b.actions);
  swap(a.name, b.name);
  swap(a.__isset, b.__isset);
}

Reaction::Reaction(const Reaction& other72) {
  matchers = other72.matchers;
  actions = other72.actions;
  name = other72.name;
  __isset = other72.__isset;
}
Reaction& Reaction::operator=(const Reaction& other73) {
  matchers = other73.matchers;
  actions = other73.actions;
  name = other73.name;
  __isset = other73.__isset;
  return *this;
}
void Reaction::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "Reaction(";
  out << "matchers=" << to_string(matchers);
  out << ", " << "actions=" << to_string(actions);
  out << ", " << "name=" << to_string(name);
  out << ")";
}

}}}} // namespace
