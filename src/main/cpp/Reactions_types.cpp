/**
 * Autogenerated by Thrift Compiler (0.9.3)
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *  @generated
 */
#include "Reactions_types.h"

#include <algorithm>
#include <ostream>

#include <thrift/TToString.h>

namespace tech { namespace aroma { namespace thrift { namespace reactions {


MatcherAll::~MatcherAll() throw() {
}


uint32_t MatcherAll::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    xfer += iprot->skip(ftype);
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t MatcherAll::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("MatcherAll");

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(MatcherAll &a, MatcherAll &b) {
  using ::std::swap;
  (void) a;
  (void) b;
}

MatcherAll::MatcherAll(const MatcherAll& other0) {
  (void) other0;
}
MatcherAll& MatcherAll::operator=(const MatcherAll& other1) {
  (void) other1;
  return *this;
}
void MatcherAll::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "MatcherAll(";
  out << ")";
}


MatcherTitleIs::~MatcherTitleIs() throw() {
}


void MatcherTitleIs::__set_expectedTitle(const std::string& val) {
  this->expectedTitle = val;
}

uint32_t MatcherTitleIs::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->expectedTitle);
          this->__isset.expectedTitle = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t MatcherTitleIs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("MatcherTitleIs");

  xfer += oprot->writeFieldBegin("expectedTitle", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->expectedTitle);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(MatcherTitleIs &a, MatcherTitleIs &b) {
  using ::std::swap;
  swap(a.expectedTitle, b.expectedTitle);
  swap(a.__isset, b.__isset);
}

MatcherTitleIs::MatcherTitleIs(const MatcherTitleIs& other2) {
  expectedTitle = other2.expectedTitle;
  __isset = other2.__isset;
}
MatcherTitleIs& MatcherTitleIs::operator=(const MatcherTitleIs& other3) {
  expectedTitle = other3.expectedTitle;
  __isset = other3.__isset;
  return *this;
}
void MatcherTitleIs::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "MatcherTitleIs(";
  out << "expectedTitle=" << to_string(expectedTitle);
  out << ")";
}


MatcherTitleContains::~MatcherTitleContains() throw() {
}


void MatcherTitleContains::__set_substring(const std::string& val) {
  this->substring = val;
}

uint32_t MatcherTitleContains::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->substring);
          this->__isset.substring = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t MatcherTitleContains::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("MatcherTitleContains");

  xfer += oprot->writeFieldBegin("substring", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->substring);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(MatcherTitleContains &a, MatcherTitleContains &b) {
  using ::std::swap;
  swap(a.substring, b.substring);
  swap(a.__isset, b.__isset);
}

MatcherTitleContains::MatcherTitleContains(const MatcherTitleContains& other4) {
  substring = other4.substring;
  __isset = other4.__isset;
}
MatcherTitleContains& MatcherTitleContains::operator=(const MatcherTitleContains& other5) {
  substring = other5.substring;
  __isset = other5.__isset;
  return *this;
}
void MatcherTitleContains::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "MatcherTitleContains(";
  out << "substring=" << to_string(substring);
  out << ")";
}


MatcherBodyIs::~MatcherBodyIs() throw() {
}


void MatcherBodyIs::__set_expectedBody(const std::string& val) {
  this->expectedBody = val;
}

uint32_t MatcherBodyIs::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->expectedBody);
          this->__isset.expectedBody = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t MatcherBodyIs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("MatcherBodyIs");

  xfer += oprot->writeFieldBegin("expectedBody", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->expectedBody);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(MatcherBodyIs &a, MatcherBodyIs &b) {
  using ::std::swap;
  swap(a.expectedBody, b.expectedBody);
  swap(a.__isset, b.__isset);
}

MatcherBodyIs::MatcherBodyIs(const MatcherBodyIs& other6) {
  expectedBody = other6.expectedBody;
  __isset = other6.__isset;
}
MatcherBodyIs& MatcherBodyIs::operator=(const MatcherBodyIs& other7) {
  expectedBody = other7.expectedBody;
  __isset = other7.__isset;
  return *this;
}
void MatcherBodyIs::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "MatcherBodyIs(";
  out << "expectedBody=" << to_string(expectedBody);
  out << ")";
}


MatcherBodyContains::~MatcherBodyContains() throw() {
}


void MatcherBodyContains::__set_substring(const std::string& val) {
  this->substring = val;
}

uint32_t MatcherBodyContains::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->substring);
          this->__isset.substring = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t MatcherBodyContains::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("MatcherBodyContains");

  xfer += oprot->writeFieldBegin("substring", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->substring);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(MatcherBodyContains &a, MatcherBodyContains &b) {
  using ::std::swap;
  swap(a.substring, b.substring);
  swap(a.__isset, b.__isset);
}

MatcherBodyContains::MatcherBodyContains(const MatcherBodyContains& other8) {
  substring = other8.substring;
  __isset = other8.__isset;
}
MatcherBodyContains& MatcherBodyContains::operator=(const MatcherBodyContains& other9) {
  substring = other9.substring;
  __isset = other9.__isset;
  return *this;
}
void MatcherBodyContains::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "MatcherBodyContains(";
  out << "substring=" << to_string(substring);
  out << ")";
}


MatcherUrgencyIs::~MatcherUrgencyIs() throw() {
}


void MatcherUrgencyIs::__set_urgency(const  ::tech::aroma::thrift::Urgency::type val) {
  this->urgency = val;
}

uint32_t MatcherUrgencyIs::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast10;
          xfer += iprot->readI32(ecast10);
          this->urgency = ( ::tech::aroma::thrift::Urgency::type)ecast10;
          this->__isset.urgency = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t MatcherUrgencyIs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("MatcherUrgencyIs");

  xfer += oprot->writeFieldBegin("urgency", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32((int32_t)this->urgency);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(MatcherUrgencyIs &a, MatcherUrgencyIs &b) {
  using ::std::swap;
  swap(a.urgency, b.urgency);
  swap(a.__isset, b.__isset);
}

MatcherUrgencyIs::MatcherUrgencyIs(const MatcherUrgencyIs& other11) {
  urgency = other11.urgency;
  __isset = other11.__isset;
}
MatcherUrgencyIs& MatcherUrgencyIs::operator=(const MatcherUrgencyIs& other12) {
  urgency = other12.urgency;
  __isset = other12.__isset;
  return *this;
}
void MatcherUrgencyIs::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "MatcherUrgencyIs(";
  out << "urgency=" << to_string(urgency);
  out << ")";
}


MatcherHostnameIs::~MatcherHostnameIs() throw() {
}


void MatcherHostnameIs::__set_expectedHostname(const std::string& val) {
  this->expectedHostname = val;
}

uint32_t MatcherHostnameIs::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->expectedHostname);
          this->__isset.expectedHostname = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t MatcherHostnameIs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("MatcherHostnameIs");

  xfer += oprot->writeFieldBegin("expectedHostname", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->expectedHostname);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(MatcherHostnameIs &a, MatcherHostnameIs &b) {
  using ::std::swap;
  swap(a.expectedHostname, b.expectedHostname);
  swap(a.__isset, b.__isset);
}

MatcherHostnameIs::MatcherHostnameIs(const MatcherHostnameIs& other13) {
  expectedHostname = other13.expectedHostname;
  __isset = other13.__isset;
}
MatcherHostnameIs& MatcherHostnameIs::operator=(const MatcherHostnameIs& other14) {
  expectedHostname = other14.expectedHostname;
  __isset = other14.__isset;
  return *this;
}
void MatcherHostnameIs::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "MatcherHostnameIs(";
  out << "expectedHostname=" << to_string(expectedHostname);
  out << ")";
}


AromaMatcher::~AromaMatcher() throw() {
}


void AromaMatcher::__set_all(const MatcherAll& val) {
  this->all = val;
}

void AromaMatcher::__set_titleIs(const MatcherTitleIs& val) {
  this->titleIs = val;
}

void AromaMatcher::__set_titleContains(const MatcherTitleContains& val) {
  this->titleContains = val;
}

void AromaMatcher::__set_bodyIs(const MatcherBodyIs& val) {
  this->bodyIs = val;
}

void AromaMatcher::__set_bodyContains(const MatcherBodyContains& val) {
  this->bodyContains = val;
}

void AromaMatcher::__set_urgencyEquals(const MatcherUrgencyIs& val) {
  this->urgencyEquals = val;
}

void AromaMatcher::__set_hostnameEquals(const MatcherHostnameIs& val) {
  this->hostnameEquals = val;
}

uint32_t AromaMatcher::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->all.read(iprot);
          this->__isset.all = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->titleIs.read(iprot);
          this->__isset.titleIs = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->titleContains.read(iprot);
          this->__isset.titleContains = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->bodyIs.read(iprot);
          this->__isset.bodyIs = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->bodyContains.read(iprot);
          this->__isset.bodyContains = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->urgencyEquals.read(iprot);
          this->__isset.urgencyEquals = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->hostnameEquals.read(iprot);
          this->__isset.hostnameEquals = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t AromaMatcher::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("AromaMatcher");

  xfer += oprot->writeFieldBegin("all", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->all.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("titleIs", ::apache::thrift::protocol::T_STRUCT, 2);
  xfer += this->titleIs.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("titleContains", ::apache::thrift::protocol::T_STRUCT, 3);
  xfer += this->titleContains.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("bodyIs", ::apache::thrift::protocol::T_STRUCT, 4);
  xfer += this->bodyIs.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("bodyContains", ::apache::thrift::protocol::T_STRUCT, 5);
  xfer += this->bodyContains.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("urgencyEquals", ::apache::thrift::protocol::T_STRUCT, 6);
  xfer += this->urgencyEquals.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("hostnameEquals", ::apache::thrift::protocol::T_STRUCT, 7);
  xfer += this->hostnameEquals.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(AromaMatcher &a, AromaMatcher &b) {
  using ::std::swap;
  swap(a.all, b.all);
  swap(a.titleIs, b.titleIs);
  swap(a.titleContains, b.titleContains);
  swap(a.bodyIs, b.bodyIs);
  swap(a.bodyContains, b.bodyContains);
  swap(a.urgencyEquals, b.urgencyEquals);
  swap(a.hostnameEquals, b.hostnameEquals);
  swap(a.__isset, b.__isset);
}

AromaMatcher::AromaMatcher(const AromaMatcher& other15) {
  all = other15.all;
  titleIs = other15.titleIs;
  titleContains = other15.titleContains;
  bodyIs = other15.bodyIs;
  bodyContains = other15.bodyContains;
  urgencyEquals = other15.urgencyEquals;
  hostnameEquals = other15.hostnameEquals;
  __isset = other15.__isset;
}
AromaMatcher& AromaMatcher::operator=(const AromaMatcher& other16) {
  all = other16.all;
  titleIs = other16.titleIs;
  titleContains = other16.titleContains;
  bodyIs = other16.bodyIs;
  bodyContains = other16.bodyContains;
  urgencyEquals = other16.urgencyEquals;
  hostnameEquals = other16.hostnameEquals;
  __isset = other16.__isset;
  return *this;
}
void AromaMatcher::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "AromaMatcher(";
  out << "all=" << to_string(all);
  out << ", " << "titleIs=" << to_string(titleIs);
  out << ", " << "titleContains=" << to_string(titleContains);
  out << ", " << "bodyIs=" << to_string(bodyIs);
  out << ", " << "bodyContains=" << to_string(bodyContains);
  out << ", " << "urgencyEquals=" << to_string(urgencyEquals);
  out << ", " << "hostnameEquals=" << to_string(hostnameEquals);
  out << ")";
}


ActionForwardToSlackChannel::~ActionForwardToSlackChannel() throw() {
}


void ActionForwardToSlackChannel::__set_slackChannel(const std::string& val) {
  this->slackChannel = val;
}

void ActionForwardToSlackChannel::__set_includeBody(const bool val) {
  this->includeBody = val;
__isset.includeBody = true;
}

uint32_t ActionForwardToSlackChannel::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->slackChannel);
          this->__isset.slackChannel = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->includeBody);
          this->__isset.includeBody = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t ActionForwardToSlackChannel::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("ActionForwardToSlackChannel");

  xfer += oprot->writeFieldBegin("slackChannel", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->slackChannel);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.includeBody) {
    xfer += oprot->writeFieldBegin("includeBody", ::apache::thrift::protocol::T_BOOL, 2);
    xfer += oprot->writeBool(this->includeBody);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(ActionForwardToSlackChannel &a, ActionForwardToSlackChannel &b) {
  using ::std::swap;
  swap(a.slackChannel, b.slackChannel);
  swap(a.includeBody, b.includeBody);
  swap(a.__isset, b.__isset);
}

ActionForwardToSlackChannel::ActionForwardToSlackChannel(const ActionForwardToSlackChannel& other17) {
  slackChannel = other17.slackChannel;
  includeBody = other17.includeBody;
  __isset = other17.__isset;
}
ActionForwardToSlackChannel& ActionForwardToSlackChannel::operator=(const ActionForwardToSlackChannel& other18) {
  slackChannel = other18.slackChannel;
  includeBody = other18.includeBody;
  __isset = other18.__isset;
  return *this;
}
void ActionForwardToSlackChannel::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "ActionForwardToSlackChannel(";
  out << "slackChannel=" << to_string(slackChannel);
  out << ", " << "includeBody="; (__isset.includeBody ? (out << to_string(includeBody)) : (out << "<null>"));
  out << ")";
}


ActionForwardToSlackUser::~ActionForwardToSlackUser() throw() {
}


void ActionForwardToSlackUser::__set_slackUsername(const std::string& val) {
  this->slackUsername = val;
}

void ActionForwardToSlackUser::__set_includeBody(const bool val) {
  this->includeBody = val;
__isset.includeBody = true;
}

uint32_t ActionForwardToSlackUser::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->slackUsername);
          this->__isset.slackUsername = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->includeBody);
          this->__isset.includeBody = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t ActionForwardToSlackUser::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("ActionForwardToSlackUser");

  xfer += oprot->writeFieldBegin("slackUsername", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->slackUsername);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.includeBody) {
    xfer += oprot->writeFieldBegin("includeBody", ::apache::thrift::protocol::T_BOOL, 2);
    xfer += oprot->writeBool(this->includeBody);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(ActionForwardToSlackUser &a, ActionForwardToSlackUser &b) {
  using ::std::swap;
  swap(a.slackUsername, b.slackUsername);
  swap(a.includeBody, b.includeBody);
  swap(a.__isset, b.__isset);
}

ActionForwardToSlackUser::ActionForwardToSlackUser(const ActionForwardToSlackUser& other19) {
  slackUsername = other19.slackUsername;
  includeBody = other19.includeBody;
  __isset = other19.__isset;
}
ActionForwardToSlackUser& ActionForwardToSlackUser::operator=(const ActionForwardToSlackUser& other20) {
  slackUsername = other20.slackUsername;
  includeBody = other20.includeBody;
  __isset = other20.__isset;
  return *this;
}
void ActionForwardToSlackUser::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "ActionForwardToSlackUser(";
  out << "slackUsername=" << to_string(slackUsername);
  out << ", " << "includeBody="; (__isset.includeBody ? (out << to_string(includeBody)) : (out << "<null>"));
  out << ")";
}


ActionSendEmail::~ActionSendEmail() throw() {
}


void ActionSendEmail::__set_emailAddress(const std::string& val) {
  this->emailAddress = val;
}

void ActionSendEmail::__set_includeBody(const bool val) {
  this->includeBody = val;
__isset.includeBody = true;
}

uint32_t ActionSendEmail::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->emailAddress);
          this->__isset.emailAddress = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->includeBody);
          this->__isset.includeBody = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t ActionSendEmail::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("ActionSendEmail");

  xfer += oprot->writeFieldBegin("emailAddress", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->emailAddress);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.includeBody) {
    xfer += oprot->writeFieldBegin("includeBody", ::apache::thrift::protocol::T_BOOL, 2);
    xfer += oprot->writeBool(this->includeBody);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(ActionSendEmail &a, ActionSendEmail &b) {
  using ::std::swap;
  swap(a.emailAddress, b.emailAddress);
  swap(a.includeBody, b.includeBody);
  swap(a.__isset, b.__isset);
}

ActionSendEmail::ActionSendEmail(const ActionSendEmail& other21) {
  emailAddress = other21.emailAddress;
  includeBody = other21.includeBody;
  __isset = other21.__isset;
}
ActionSendEmail& ActionSendEmail::operator=(const ActionSendEmail& other22) {
  emailAddress = other22.emailAddress;
  includeBody = other22.includeBody;
  __isset = other22.__isset;
  return *this;
}
void ActionSendEmail::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "ActionSendEmail(";
  out << "emailAddress=" << to_string(emailAddress);
  out << ", " << "includeBody="; (__isset.includeBody ? (out << to_string(includeBody)) : (out << "<null>"));
  out << ")";
}


ActionSkipInbox::~ActionSkipInbox() throw() {
}


uint32_t ActionSkipInbox::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    xfer += iprot->skip(ftype);
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t ActionSkipInbox::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("ActionSkipInbox");

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(ActionSkipInbox &a, ActionSkipInbox &b) {
  using ::std::swap;
  (void) a;
  (void) b;
}

ActionSkipInbox::ActionSkipInbox(const ActionSkipInbox& other23) {
  (void) other23;
}
ActionSkipInbox& ActionSkipInbox::operator=(const ActionSkipInbox& other24) {
  (void) other24;
  return *this;
}
void ActionSkipInbox::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "ActionSkipInbox(";
  out << ")";
}


ActionDeleteMessage::~ActionDeleteMessage() throw() {
}


uint32_t ActionDeleteMessage::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    xfer += iprot->skip(ftype);
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t ActionDeleteMessage::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("ActionDeleteMessage");

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(ActionDeleteMessage &a, ActionDeleteMessage &b) {
  using ::std::swap;
  (void) a;
  (void) b;
}

ActionDeleteMessage::ActionDeleteMessage(const ActionDeleteMessage& other25) {
  (void) other25;
}
ActionDeleteMessage& ActionDeleteMessage::operator=(const ActionDeleteMessage& other26) {
  (void) other26;
  return *this;
}
void ActionDeleteMessage::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "ActionDeleteMessage(";
  out << ")";
}


ActionRespondToCode::~ActionRespondToCode() throw() {
}


void ActionRespondToCode::__set_messageToSend(const std::string& val) {
  this->messageToSend = val;
}

uint32_t ActionRespondToCode::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->messageToSend);
          this->__isset.messageToSend = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t ActionRespondToCode::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("ActionRespondToCode");

  xfer += oprot->writeFieldBegin("messageToSend", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->messageToSend);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(ActionRespondToCode &a, ActionRespondToCode &b) {
  using ::std::swap;
  swap(a.messageToSend, b.messageToSend);
  swap(a.__isset, b.__isset);
}

ActionRespondToCode::ActionRespondToCode(const ActionRespondToCode& other27) {
  messageToSend = other27.messageToSend;
  __isset = other27.__isset;
}
ActionRespondToCode& ActionRespondToCode::operator=(const ActionRespondToCode& other28) {
  messageToSend = other28.messageToSend;
  __isset = other28.__isset;
  return *this;
}
void ActionRespondToCode::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "ActionRespondToCode(";
  out << "messageToSend=" << to_string(messageToSend);
  out << ")";
}


ActionForwardToUsers::~ActionForwardToUsers() throw() {
}


void ActionForwardToUsers::__set_userIds(const std::vector<uuid> & val) {
  this->userIds = val;
}

uint32_t ActionForwardToUsers::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->userIds.clear();
            uint32_t _size29;
            ::apache::thrift::protocol::TType _etype32;
            xfer += iprot->readListBegin(_etype32, _size29);
            this->userIds.resize(_size29);
            uint32_t _i33;
            for (_i33 = 0; _i33 < _size29; ++_i33)
            {
              xfer += iprot->readString(this->userIds[_i33]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.userIds = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t ActionForwardToUsers::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("ActionForwardToUsers");

  xfer += oprot->writeFieldBegin("userIds", ::apache::thrift::protocol::T_LIST, 1);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->userIds.size()));
    std::vector<uuid> ::const_iterator _iter34;
    for (_iter34 = this->userIds.begin(); _iter34 != this->userIds.end(); ++_iter34)
    {
      xfer += oprot->writeString((*_iter34));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(ActionForwardToUsers &a, ActionForwardToUsers &b) {
  using ::std::swap;
  swap(a.userIds, b.userIds);
  swap(a.__isset, b.__isset);
}

ActionForwardToUsers::ActionForwardToUsers(const ActionForwardToUsers& other35) {
  userIds = other35.userIds;
  __isset = other35.__isset;
}
ActionForwardToUsers& ActionForwardToUsers::operator=(const ActionForwardToUsers& other36) {
  userIds = other36.userIds;
  __isset = other36.__isset;
  return *this;
}
void ActionForwardToUsers::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "ActionForwardToUsers(";
  out << "userIds=" << to_string(userIds);
  out << ")";
}


AromaAction::~AromaAction() throw() {
}


void AromaAction::__set_forwardToSlackChannel(const ActionForwardToSlackChannel& val) {
  this->forwardToSlackChannel = val;
}

void AromaAction::__set_forwardToSlackUser(const ActionForwardToSlackUser& val) {
  this->forwardToSlackUser = val;
}

void AromaAction::__set_sendEmail(const ActionSendEmail& val) {
  this->sendEmail = val;
}

void AromaAction::__set_skipInbox(const ActionSkipInbox& val) {
  this->skipInbox = val;
}

void AromaAction::__set_deleteMessage(const ActionDeleteMessage& val) {
  this->deleteMessage = val;
}

void AromaAction::__set_respondToCode(const ActionRespondToCode& val) {
  this->respondToCode = val;
}

void AromaAction::__set_forwardToUsers(const ActionForwardToUsers& val) {
  this->forwardToUsers = val;
}

uint32_t AromaAction::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->forwardToSlackChannel.read(iprot);
          this->__isset.forwardToSlackChannel = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->forwardToSlackUser.read(iprot);
          this->__isset.forwardToSlackUser = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->sendEmail.read(iprot);
          this->__isset.sendEmail = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->skipInbox.read(iprot);
          this->__isset.skipInbox = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->deleteMessage.read(iprot);
          this->__isset.deleteMessage = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->respondToCode.read(iprot);
          this->__isset.respondToCode = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->forwardToUsers.read(iprot);
          this->__isset.forwardToUsers = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t AromaAction::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("AromaAction");

  xfer += oprot->writeFieldBegin("forwardToSlackChannel", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->forwardToSlackChannel.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("forwardToSlackUser", ::apache::thrift::protocol::T_STRUCT, 2);
  xfer += this->forwardToSlackUser.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("sendEmail", ::apache::thrift::protocol::T_STRUCT, 3);
  xfer += this->sendEmail.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("skipInbox", ::apache::thrift::protocol::T_STRUCT, 4);
  xfer += this->skipInbox.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("deleteMessage", ::apache::thrift::protocol::T_STRUCT, 5);
  xfer += this->deleteMessage.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("respondToCode", ::apache::thrift::protocol::T_STRUCT, 6);
  xfer += this->respondToCode.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("forwardToUsers", ::apache::thrift::protocol::T_STRUCT, 7);
  xfer += this->forwardToUsers.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(AromaAction &a, AromaAction &b) {
  using ::std::swap;
  swap(a.forwardToSlackChannel, b.forwardToSlackChannel);
  swap(a.forwardToSlackUser, b.forwardToSlackUser);
  swap(a.sendEmail, b.sendEmail);
  swap(a.skipInbox, b.skipInbox);
  swap(a.deleteMessage, b.deleteMessage);
  swap(a.respondToCode, b.respondToCode);
  swap(a.forwardToUsers, b.forwardToUsers);
  swap(a.__isset, b.__isset);
}

AromaAction::AromaAction(const AromaAction& other37) {
  forwardToSlackChannel = other37.forwardToSlackChannel;
  forwardToSlackUser = other37.forwardToSlackUser;
  sendEmail = other37.sendEmail;
  skipInbox = other37.skipInbox;
  deleteMessage = other37.deleteMessage;
  respondToCode = other37.respondToCode;
  forwardToUsers = other37.forwardToUsers;
  __isset = other37.__isset;
}
AromaAction& AromaAction::operator=(const AromaAction& other38) {
  forwardToSlackChannel = other38.forwardToSlackChannel;
  forwardToSlackUser = other38.forwardToSlackUser;
  sendEmail = other38.sendEmail;
  skipInbox = other38.skipInbox;
  deleteMessage = other38.deleteMessage;
  respondToCode = other38.respondToCode;
  forwardToUsers = other38.forwardToUsers;
  __isset = other38.__isset;
  return *this;
}
void AromaAction::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "AromaAction(";
  out << "forwardToSlackChannel=" << to_string(forwardToSlackChannel);
  out << ", " << "forwardToSlackUser=" << to_string(forwardToSlackUser);
  out << ", " << "sendEmail=" << to_string(sendEmail);
  out << ", " << "skipInbox=" << to_string(skipInbox);
  out << ", " << "deleteMessage=" << to_string(deleteMessage);
  out << ", " << "respondToCode=" << to_string(respondToCode);
  out << ", " << "forwardToUsers=" << to_string(forwardToUsers);
  out << ")";
}


Reaction::~Reaction() throw() {
}


void Reaction::__set_matcher(const AromaMatcher& val) {
  this->matcher = val;
}

void Reaction::__set_action(const AromaAction& val) {
  this->action = val;
}

void Reaction::__set_name(const std::string& val) {
  this->name = val;
}

uint32_t Reaction::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->matcher.read(iprot);
          this->__isset.matcher = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->action.read(iprot);
          this->__isset.action = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->name);
          this->__isset.name = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t Reaction::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("Reaction");

  xfer += oprot->writeFieldBegin("matcher", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->matcher.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("action", ::apache::thrift::protocol::T_STRUCT, 2);
  xfer += this->action.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("name", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeString(this->name);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(Reaction &a, Reaction &b) {
  using ::std::swap;
  swap(a.matcher, b.matcher);
  swap(a.action, b.action);
  swap(a.name, b.name);
  swap(a.__isset, b.__isset);
}

Reaction::Reaction(const Reaction& other39) {
  matcher = other39.matcher;
  action = other39.action;
  name = other39.name;
  __isset = other39.__isset;
}
Reaction& Reaction::operator=(const Reaction& other40) {
  matcher = other40.matcher;
  action = other40.action;
  name = other40.name;
  __isset = other40.__isset;
  return *this;
}
void Reaction::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "Reaction(";
  out << "matcher=" << to_string(matcher);
  out << ", " << "action=" << to_string(action);
  out << ", " << "name=" << to_string(name);
  out << ")";
}

}}}} // namespace
