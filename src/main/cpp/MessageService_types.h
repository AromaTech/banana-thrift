/**
 * Autogenerated by Thrift Compiler (0.9.3)
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *  @generated
 */
#ifndef MessageService_TYPES_H
#define MessageService_TYPES_H

#include <iosfwd>

#include <thrift/Thrift.h>
#include <thrift/TApplicationException.h>
#include <thrift/protocol/TProtocol.h>
#include <thrift/transport/TTransport.h>

#include <thrift/cxxfunctional.h>
#include "Authentication_types.h"
#include "Banana_types.h"
#include "Channels_types.h"
#include "Endpoint_types.h"
#include "Events_types.h"
#include "Exceptions_types.h"


namespace aroma { namespace banana { namespace thrift { namespace message { namespace service {

typedef  ::aroma::banana::thrift::int int;

typedef  ::aroma::banana::thrift::long long;

typedef  ::aroma::banana::thrift::timestamp timestamp;

typedef class  ::aroma::banana::thrift::authentication::ApplicationToken ApplicationToken;

typedef class  ::aroma::banana::thrift::authentication::AuthenticationToken AuthenticationToken;

typedef class  ::aroma::banana::thrift::authentication::UserToken UserToken;

typedef class  ::aroma::banana::thrift::Application Application;

typedef  ::aroma::banana::thrift::Urgency::type Urgency;

typedef class  ::aroma::banana::thrift::events::Event Event;

typedef class  ::aroma::banana::thrift::exceptions::AccountAlreadyExistsException AccountAlreadyExistsException;

typedef class  ::aroma::banana::thrift::exceptions::InvalidArgumentException InvalidArgumentException;

typedef class  ::aroma::banana::thrift::exceptions::InvalidCredentialsException InvalidCredentialsException;

typedef class  ::aroma::banana::thrift::exceptions::InvalidTokenException InvalidTokenException;

typedef class  ::aroma::banana::thrift::exceptions::OperationFailedException OperationFailedException;

typedef class  ::aroma::banana::thrift::exceptions::ApplicationAlreadyRegisteredException ApplicationAlreadyRegisteredException;

typedef class  ::aroma::banana::thrift::exceptions::ApplicationDoesNotExistException ApplicationDoesNotExistException;

typedef class  ::aroma::banana::thrift::exceptions::CustomChannelUnreachableException CustomChannelUnreachableException;

typedef class  ::aroma::banana::thrift::exceptions::ChannelDoesNotExistException ChannelDoesNotExistException;

typedef class  ::aroma::banana::thrift::exceptions::UnauthorizedException UnauthorizedException;

class SendMessageRequest;

class SendMessageResponse;

class DeleteMessageRequest;

class DeleteMessageResponse;

class DismissMessageRequest;

class DismissMessageResponse;

class GetMessagesRequest;

class GetMessagesResponse;

class GetFullMessageRequest;

class GetFullMessageResponse;

typedef struct _SendMessageRequest__isset {
  _SendMessageRequest__isset() : applicationToken(false), message(false), urgency(true), timeOfMessage(false) {}
  bool applicationToken :1;
  bool message :1;
  bool urgency :1;
  bool timeOfMessage :1;
} _SendMessageRequest__isset;

class SendMessageRequest {
 public:

  SendMessageRequest(const SendMessageRequest&);
  SendMessageRequest& operator=(const SendMessageRequest&);
  SendMessageRequest() : message(), urgency(( ::aroma::banana::thrift::Urgency::type)1), timeOfMessage(0) {
    urgency = ( ::aroma::banana::thrift::Urgency::type)1;

  }

  virtual ~SendMessageRequest() throw();
  ApplicationToken applicationToken;
  std::string message;
  Urgency urgency;
  timestamp timeOfMessage;

  _SendMessageRequest__isset __isset;

  void __set_applicationToken(const ApplicationToken& val);

  void __set_message(const std::string& val);

  void __set_urgency(const Urgency val);

  void __set_timeOfMessage(const timestamp val);

  bool operator == (const SendMessageRequest & rhs) const
  {
    if (!(applicationToken == rhs.applicationToken))
      return false;
    if (!(message == rhs.message))
      return false;
    if (!(urgency == rhs.urgency))
      return false;
    if (__isset.timeOfMessage != rhs.__isset.timeOfMessage)
      return false;
    else if (__isset.timeOfMessage && !(timeOfMessage == rhs.timeOfMessage))
      return false;
    return true;
  }
  bool operator != (const SendMessageRequest &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const SendMessageRequest & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(SendMessageRequest &a, SendMessageRequest &b);

inline std::ostream& operator<<(std::ostream& out, const SendMessageRequest& obj)
{
  obj.printTo(out);
  return out;
}

typedef struct _SendMessageResponse__isset {
  _SendMessageResponse__isset() : messageId(false) {}
  bool messageId :1;
} _SendMessageResponse__isset;

class SendMessageResponse {
 public:

  SendMessageResponse(const SendMessageResponse&);
  SendMessageResponse& operator=(const SendMessageResponse&);
  SendMessageResponse() : messageId() {
  }

  virtual ~SendMessageResponse() throw();
  std::string messageId;

  _SendMessageResponse__isset __isset;

  void __set_messageId(const std::string& val);

  bool operator == (const SendMessageResponse & rhs) const
  {
    if (!(messageId == rhs.messageId))
      return false;
    return true;
  }
  bool operator != (const SendMessageResponse &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const SendMessageResponse & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(SendMessageResponse &a, SendMessageResponse &b);

inline std::ostream& operator<<(std::ostream& out, const SendMessageResponse& obj)
{
  obj.printTo(out);
  return out;
}

typedef struct _DeleteMessageRequest__isset {
  _DeleteMessageRequest__isset() : token(false), messageId(false), applicationId(false), messageIds(true) {}
  bool token :1;
  bool messageId :1;
  bool applicationId :1;
  bool messageIds :1;
} _DeleteMessageRequest__isset;

class DeleteMessageRequest {
 public:

  DeleteMessageRequest(const DeleteMessageRequest&);
  DeleteMessageRequest& operator=(const DeleteMessageRequest&);
  DeleteMessageRequest() : messageId(), applicationId() {

  }

  virtual ~DeleteMessageRequest() throw();
  UserToken token;
  std::string messageId;
  std::string applicationId;
  std::vector<std::string>  messageIds;

  _DeleteMessageRequest__isset __isset;

  void __set_token(const UserToken& val);

  void __set_messageId(const std::string& val);

  void __set_applicationId(const std::string& val);

  void __set_messageIds(const std::vector<std::string> & val);

  bool operator == (const DeleteMessageRequest & rhs) const
  {
    if (!(token == rhs.token))
      return false;
    if (!(messageId == rhs.messageId))
      return false;
    if (!(applicationId == rhs.applicationId))
      return false;
    if (__isset.messageIds != rhs.__isset.messageIds)
      return false;
    else if (__isset.messageIds && !(messageIds == rhs.messageIds))
      return false;
    return true;
  }
  bool operator != (const DeleteMessageRequest &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const DeleteMessageRequest & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(DeleteMessageRequest &a, DeleteMessageRequest &b);

inline std::ostream& operator<<(std::ostream& out, const DeleteMessageRequest& obj)
{
  obj.printTo(out);
  return out;
}

typedef struct _DeleteMessageResponse__isset {
  _DeleteMessageResponse__isset() : messagesDeleted(true) {}
  bool messagesDeleted :1;
} _DeleteMessageResponse__isset;

class DeleteMessageResponse {
 public:

  DeleteMessageResponse(const DeleteMessageResponse&);
  DeleteMessageResponse& operator=(const DeleteMessageResponse&);
  DeleteMessageResponse() : messagesDeleted(0) {
  }

  virtual ~DeleteMessageResponse() throw();
  int messagesDeleted;

  _DeleteMessageResponse__isset __isset;

  void __set_messagesDeleted(const int val);

  bool operator == (const DeleteMessageResponse & rhs) const
  {
    if (__isset.messagesDeleted != rhs.__isset.messagesDeleted)
      return false;
    else if (__isset.messagesDeleted && !(messagesDeleted == rhs.messagesDeleted))
      return false;
    return true;
  }
  bool operator != (const DeleteMessageResponse &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const DeleteMessageResponse & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(DeleteMessageResponse &a, DeleteMessageResponse &b);

inline std::ostream& operator<<(std::ostream& out, const DeleteMessageResponse& obj)
{
  obj.printTo(out);
  return out;
}

typedef struct _DismissMessageRequest__isset {
  _DismissMessageRequest__isset() : token(false), messageId(false), applicationId(false), messageIds(true) {}
  bool token :1;
  bool messageId :1;
  bool applicationId :1;
  bool messageIds :1;
} _DismissMessageRequest__isset;

class DismissMessageRequest {
 public:

  DismissMessageRequest(const DismissMessageRequest&);
  DismissMessageRequest& operator=(const DismissMessageRequest&);
  DismissMessageRequest() : messageId(), applicationId() {

  }

  virtual ~DismissMessageRequest() throw();
  UserToken token;
  std::string messageId;
  std::string applicationId;
  std::vector<std::string>  messageIds;

  _DismissMessageRequest__isset __isset;

  void __set_token(const UserToken& val);

  void __set_messageId(const std::string& val);

  void __set_applicationId(const std::string& val);

  void __set_messageIds(const std::vector<std::string> & val);

  bool operator == (const DismissMessageRequest & rhs) const
  {
    if (!(token == rhs.token))
      return false;
    if (!(messageId == rhs.messageId))
      return false;
    if (!(applicationId == rhs.applicationId))
      return false;
    if (__isset.messageIds != rhs.__isset.messageIds)
      return false;
    else if (__isset.messageIds && !(messageIds == rhs.messageIds))
      return false;
    return true;
  }
  bool operator != (const DismissMessageRequest &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const DismissMessageRequest & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(DismissMessageRequest &a, DismissMessageRequest &b);

inline std::ostream& operator<<(std::ostream& out, const DismissMessageRequest& obj)
{
  obj.printTo(out);
  return out;
}

typedef struct _DismissMessageResponse__isset {
  _DismissMessageResponse__isset() : messagesDismissed(true) {}
  bool messagesDismissed :1;
} _DismissMessageResponse__isset;

class DismissMessageResponse {
 public:

  DismissMessageResponse(const DismissMessageResponse&);
  DismissMessageResponse& operator=(const DismissMessageResponse&);
  DismissMessageResponse() : messagesDismissed(0) {
  }

  virtual ~DismissMessageResponse() throw();
  int messagesDismissed;

  _DismissMessageResponse__isset __isset;

  void __set_messagesDismissed(const int val);

  bool operator == (const DismissMessageResponse & rhs) const
  {
    if (__isset.messagesDismissed != rhs.__isset.messagesDismissed)
      return false;
    else if (__isset.messagesDismissed && !(messagesDismissed == rhs.messagesDismissed))
      return false;
    return true;
  }
  bool operator != (const DismissMessageResponse &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const DismissMessageResponse & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(DismissMessageResponse &a, DismissMessageResponse &b);

inline std::ostream& operator<<(std::ostream& out, const DismissMessageResponse& obj)
{
  obj.printTo(out);
  return out;
}

typedef struct _GetMessagesRequest__isset {
  _GetMessagesRequest__isset() : token(false), applicationId(false), limit(true) {}
  bool token :1;
  bool applicationId :1;
  bool limit :1;
} _GetMessagesRequest__isset;

class GetMessagesRequest {
 public:

  GetMessagesRequest(const GetMessagesRequest&);
  GetMessagesRequest& operator=(const GetMessagesRequest&);
  GetMessagesRequest() : applicationId(), limit(0) {
  }

  virtual ~GetMessagesRequest() throw();
  UserToken token;
  std::string applicationId;
  int limit;

  _GetMessagesRequest__isset __isset;

  void __set_token(const UserToken& val);

  void __set_applicationId(const std::string& val);

  void __set_limit(const int val);

  bool operator == (const GetMessagesRequest & rhs) const
  {
    if (!(token == rhs.token))
      return false;
    if (__isset.applicationId != rhs.__isset.applicationId)
      return false;
    else if (__isset.applicationId && !(applicationId == rhs.applicationId))
      return false;
    if (__isset.limit != rhs.__isset.limit)
      return false;
    else if (__isset.limit && !(limit == rhs.limit))
      return false;
    return true;
  }
  bool operator != (const GetMessagesRequest &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const GetMessagesRequest & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(GetMessagesRequest &a, GetMessagesRequest &b);

inline std::ostream& operator<<(std::ostream& out, const GetMessagesRequest& obj)
{
  obj.printTo(out);
  return out;
}

typedef struct _GetMessagesResponse__isset {
  _GetMessagesResponse__isset() : messages(true), totalMessagesMatching(true) {}
  bool messages :1;
  bool totalMessagesMatching :1;
} _GetMessagesResponse__isset;

class GetMessagesResponse {
 public:

  GetMessagesResponse(const GetMessagesResponse&);
  GetMessagesResponse& operator=(const GetMessagesResponse&);
  GetMessagesResponse() : totalMessagesMatching(0) {

  }

  virtual ~GetMessagesResponse() throw();
  std::vector< ::aroma::banana::thrift::Message>  messages;
  int totalMessagesMatching;

  _GetMessagesResponse__isset __isset;

  void __set_messages(const std::vector< ::aroma::banana::thrift::Message> & val);

  void __set_totalMessagesMatching(const int val);

  bool operator == (const GetMessagesResponse & rhs) const
  {
    if (!(messages == rhs.messages))
      return false;
    if (__isset.totalMessagesMatching != rhs.__isset.totalMessagesMatching)
      return false;
    else if (__isset.totalMessagesMatching && !(totalMessagesMatching == rhs.totalMessagesMatching))
      return false;
    return true;
  }
  bool operator != (const GetMessagesResponse &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const GetMessagesResponse & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(GetMessagesResponse &a, GetMessagesResponse &b);

inline std::ostream& operator<<(std::ostream& out, const GetMessagesResponse& obj)
{
  obj.printTo(out);
  return out;
}

typedef struct _GetFullMessageRequest__isset {
  _GetFullMessageRequest__isset() : token(false), messageId(false) {}
  bool token :1;
  bool messageId :1;
} _GetFullMessageRequest__isset;

class GetFullMessageRequest {
 public:

  GetFullMessageRequest(const GetFullMessageRequest&);
  GetFullMessageRequest& operator=(const GetFullMessageRequest&);
  GetFullMessageRequest() : messageId() {
  }

  virtual ~GetFullMessageRequest() throw();
  UserToken token;
  std::string messageId;

  _GetFullMessageRequest__isset __isset;

  void __set_token(const UserToken& val);

  void __set_messageId(const std::string& val);

  bool operator == (const GetFullMessageRequest & rhs) const
  {
    if (!(token == rhs.token))
      return false;
    if (!(messageId == rhs.messageId))
      return false;
    return true;
  }
  bool operator != (const GetFullMessageRequest &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const GetFullMessageRequest & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(GetFullMessageRequest &a, GetFullMessageRequest &b);

inline std::ostream& operator<<(std::ostream& out, const GetFullMessageRequest& obj)
{
  obj.printTo(out);
  return out;
}

typedef struct _GetFullMessageResponse__isset {
  _GetFullMessageResponse__isset() : fullBody(false) {}
  bool fullBody :1;
} _GetFullMessageResponse__isset;

class GetFullMessageResponse {
 public:

  GetFullMessageResponse(const GetFullMessageResponse&);
  GetFullMessageResponse& operator=(const GetFullMessageResponse&);
  GetFullMessageResponse() : fullBody() {
  }

  virtual ~GetFullMessageResponse() throw();
  std::string fullBody;

  _GetFullMessageResponse__isset __isset;

  void __set_fullBody(const std::string& val);

  bool operator == (const GetFullMessageResponse & rhs) const
  {
    if (!(fullBody == rhs.fullBody))
      return false;
    return true;
  }
  bool operator != (const GetFullMessageResponse &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const GetFullMessageResponse & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(GetFullMessageResponse &a, GetFullMessageResponse &b);

inline std::ostream& operator<<(std::ostream& out, const GetFullMessageResponse& obj)
{
  obj.printTo(out);
  return out;
}

}}}}} // namespace

#endif
