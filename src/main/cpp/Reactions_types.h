/**
 * Autogenerated by Thrift Compiler (0.9.3)
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *  @generated
 */
#ifndef Reactions_TYPES_H
#define Reactions_TYPES_H

#include <iosfwd>

#include <thrift/Thrift.h>
#include <thrift/TApplicationException.h>
#include <thrift/protocol/TProtocol.h>
#include <thrift/transport/TTransport.h>

#include <thrift/cxxfunctional.h>
#include "Aroma_types.h"
#include "Exceptions_types.h"


namespace tech { namespace aroma { namespace thrift { namespace reactions {

typedef  ::tech::aroma::thrift::int int;

typedef  ::tech::aroma::thrift::long long;

typedef  ::tech::aroma::thrift::timestamp timestamp;

class MatcherAll;

class MatcherTitleIs;

class MatcherTitleContains;

class MatcherBodyIs;

class MatcherBodyContains;

class MatcherUrgencyEquals;

class MatcherHostnameEquals;

class Matcher;


class MatcherAll {
 public:

  MatcherAll(const MatcherAll&);
  MatcherAll& operator=(const MatcherAll&);
  MatcherAll() {
  }

  virtual ~MatcherAll() throw();

  bool operator == (const MatcherAll & /* rhs */) const
  {
    return true;
  }
  bool operator != (const MatcherAll &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const MatcherAll & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(MatcherAll &a, MatcherAll &b);

inline std::ostream& operator<<(std::ostream& out, const MatcherAll& obj)
{
  obj.printTo(out);
  return out;
}

typedef struct _MatcherTitleIs__isset {
  _MatcherTitleIs__isset() : expectedTitle(false) {}
  bool expectedTitle :1;
} _MatcherTitleIs__isset;

class MatcherTitleIs {
 public:

  MatcherTitleIs(const MatcherTitleIs&);
  MatcherTitleIs& operator=(const MatcherTitleIs&);
  MatcherTitleIs() : expectedTitle() {
  }

  virtual ~MatcherTitleIs() throw();
  std::string expectedTitle;

  _MatcherTitleIs__isset __isset;

  void __set_expectedTitle(const std::string& val);

  bool operator == (const MatcherTitleIs & rhs) const
  {
    if (!(expectedTitle == rhs.expectedTitle))
      return false;
    return true;
  }
  bool operator != (const MatcherTitleIs &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const MatcherTitleIs & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(MatcherTitleIs &a, MatcherTitleIs &b);

inline std::ostream& operator<<(std::ostream& out, const MatcherTitleIs& obj)
{
  obj.printTo(out);
  return out;
}

typedef struct _MatcherTitleContains__isset {
  _MatcherTitleContains__isset() : substring(false) {}
  bool substring :1;
} _MatcherTitleContains__isset;

class MatcherTitleContains {
 public:

  MatcherTitleContains(const MatcherTitleContains&);
  MatcherTitleContains& operator=(const MatcherTitleContains&);
  MatcherTitleContains() : substring() {
  }

  virtual ~MatcherTitleContains() throw();
  std::string substring;

  _MatcherTitleContains__isset __isset;

  void __set_substring(const std::string& val);

  bool operator == (const MatcherTitleContains & rhs) const
  {
    if (!(substring == rhs.substring))
      return false;
    return true;
  }
  bool operator != (const MatcherTitleContains &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const MatcherTitleContains & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(MatcherTitleContains &a, MatcherTitleContains &b);

inline std::ostream& operator<<(std::ostream& out, const MatcherTitleContains& obj)
{
  obj.printTo(out);
  return out;
}

typedef struct _MatcherBodyIs__isset {
  _MatcherBodyIs__isset() : expectedBody(false) {}
  bool expectedBody :1;
} _MatcherBodyIs__isset;

class MatcherBodyIs {
 public:

  MatcherBodyIs(const MatcherBodyIs&);
  MatcherBodyIs& operator=(const MatcherBodyIs&);
  MatcherBodyIs() : expectedBody() {
  }

  virtual ~MatcherBodyIs() throw();
  std::string expectedBody;

  _MatcherBodyIs__isset __isset;

  void __set_expectedBody(const std::string& val);

  bool operator == (const MatcherBodyIs & rhs) const
  {
    if (!(expectedBody == rhs.expectedBody))
      return false;
    return true;
  }
  bool operator != (const MatcherBodyIs &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const MatcherBodyIs & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(MatcherBodyIs &a, MatcherBodyIs &b);

inline std::ostream& operator<<(std::ostream& out, const MatcherBodyIs& obj)
{
  obj.printTo(out);
  return out;
}

typedef struct _MatcherBodyContains__isset {
  _MatcherBodyContains__isset() : substring(false) {}
  bool substring :1;
} _MatcherBodyContains__isset;

class MatcherBodyContains {
 public:

  MatcherBodyContains(const MatcherBodyContains&);
  MatcherBodyContains& operator=(const MatcherBodyContains&);
  MatcherBodyContains() : substring() {
  }

  virtual ~MatcherBodyContains() throw();
  std::string substring;

  _MatcherBodyContains__isset __isset;

  void __set_substring(const std::string& val);

  bool operator == (const MatcherBodyContains & rhs) const
  {
    if (!(substring == rhs.substring))
      return false;
    return true;
  }
  bool operator != (const MatcherBodyContains &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const MatcherBodyContains & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(MatcherBodyContains &a, MatcherBodyContains &b);

inline std::ostream& operator<<(std::ostream& out, const MatcherBodyContains& obj)
{
  obj.printTo(out);
  return out;
}

typedef struct _MatcherUrgencyEquals__isset {
  _MatcherUrgencyEquals__isset() : urgency(false) {}
  bool urgency :1;
} _MatcherUrgencyEquals__isset;

class MatcherUrgencyEquals {
 public:

  MatcherUrgencyEquals(const MatcherUrgencyEquals&);
  MatcherUrgencyEquals& operator=(const MatcherUrgencyEquals&);
  MatcherUrgencyEquals() : urgency(( ::tech::aroma::thrift::Urgency::type)0) {
  }

  virtual ~MatcherUrgencyEquals() throw();
   ::tech::aroma::thrift::Urgency::type urgency;

  _MatcherUrgencyEquals__isset __isset;

  void __set_urgency(const  ::tech::aroma::thrift::Urgency::type val);

  bool operator == (const MatcherUrgencyEquals & rhs) const
  {
    if (!(urgency == rhs.urgency))
      return false;
    return true;
  }
  bool operator != (const MatcherUrgencyEquals &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const MatcherUrgencyEquals & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(MatcherUrgencyEquals &a, MatcherUrgencyEquals &b);

inline std::ostream& operator<<(std::ostream& out, const MatcherUrgencyEquals& obj)
{
  obj.printTo(out);
  return out;
}

typedef struct _MatcherHostnameEquals__isset {
  _MatcherHostnameEquals__isset() : expectedHostname(false) {}
  bool expectedHostname :1;
} _MatcherHostnameEquals__isset;

class MatcherHostnameEquals {
 public:

  MatcherHostnameEquals(const MatcherHostnameEquals&);
  MatcherHostnameEquals& operator=(const MatcherHostnameEquals&);
  MatcherHostnameEquals() : expectedHostname() {
  }

  virtual ~MatcherHostnameEquals() throw();
  std::string expectedHostname;

  _MatcherHostnameEquals__isset __isset;

  void __set_expectedHostname(const std::string& val);

  bool operator == (const MatcherHostnameEquals & rhs) const
  {
    if (!(expectedHostname == rhs.expectedHostname))
      return false;
    return true;
  }
  bool operator != (const MatcherHostnameEquals &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const MatcherHostnameEquals & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(MatcherHostnameEquals &a, MatcherHostnameEquals &b);

inline std::ostream& operator<<(std::ostream& out, const MatcherHostnameEquals& obj)
{
  obj.printTo(out);
  return out;
}

typedef struct _Matcher__isset {
  _Matcher__isset() : all(false), titleIs(false), titleContains(false), bodyIs(false), bodyContains(false), urgencyEquals(false), hostnameEquals(false) {}
  bool all :1;
  bool titleIs :1;
  bool titleContains :1;
  bool bodyIs :1;
  bool bodyContains :1;
  bool urgencyEquals :1;
  bool hostnameEquals :1;
} _Matcher__isset;

class Matcher {
 public:

  Matcher(const Matcher&);
  Matcher& operator=(const Matcher&);
  Matcher() {
  }

  virtual ~Matcher() throw();
  MatcherAll all;
  MatcherTitleIs titleIs;
  MatcherTitleContains titleContains;
  MatcherBodyIs bodyIs;
  MatcherBodyContains bodyContains;
  MatcherUrgencyEquals urgencyEquals;
  MatcherHostnameEquals hostnameEquals;

  _Matcher__isset __isset;

  void __set_all(const MatcherAll& val);

  void __set_titleIs(const MatcherTitleIs& val);

  void __set_titleContains(const MatcherTitleContains& val);

  void __set_bodyIs(const MatcherBodyIs& val);

  void __set_bodyContains(const MatcherBodyContains& val);

  void __set_urgencyEquals(const MatcherUrgencyEquals& val);

  void __set_hostnameEquals(const MatcherHostnameEquals& val);

  bool operator == (const Matcher & rhs) const
  {
    if (!(all == rhs.all))
      return false;
    if (!(titleIs == rhs.titleIs))
      return false;
    if (!(titleContains == rhs.titleContains))
      return false;
    if (!(bodyIs == rhs.bodyIs))
      return false;
    if (!(bodyContains == rhs.bodyContains))
      return false;
    if (!(urgencyEquals == rhs.urgencyEquals))
      return false;
    if (!(hostnameEquals == rhs.hostnameEquals))
      return false;
    return true;
  }
  bool operator != (const Matcher &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Matcher & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(Matcher &a, Matcher &b);

inline std::ostream& operator<<(std::ostream& out, const Matcher& obj)
{
  obj.printTo(out);
  return out;
}

}}}} // namespace

#endif
