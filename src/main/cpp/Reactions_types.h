/**
 * Autogenerated by Thrift Compiler (0.11.0)
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *  @generated
 */
#ifndef Reactions_TYPES_H
#define Reactions_TYPES_H

#include <iosfwd>

#include <thrift/Thrift.h>
#include <thrift/TApplicationException.h>
#include <thrift/TBase.h>
#include <thrift/protocol/TProtocol.h>
#include <thrift/transport/TTransport.h>

#include <thrift/stdcxx.h>
#include "Aroma_types.h"


namespace tech { namespace aroma { namespace thrift { namespace reactions {

typedef  ::tech::aroma::thrift::int int;

typedef  ::tech::aroma::thrift::long long;

typedef  ::tech::aroma::thrift::timestamp timestamp;

typedef  ::tech::aroma::thrift::uuid uuid;

class MatcherAll;

class MatcherTitleIs;

class MatcherTitleIsNot;

class MatcherTitleContains;

class MatcherTitleDoesNotContain;

class MatcherBodyIs;

class MatcherBodyContains;

class MatcherBodyDoesNotContain;

class MatcherUrgencyIs;

class MatcherHostnameIs;

class MatcherHostnameContains;

class MatcherHostnameDoesNotContain;

class MatcherApplicationIs;

class MatcherApplicationIsNot;

class AromaMatcher;

class ActionForwardToSlackChannel;

class ActionForwardToSlackUser;

class ActionForwardToGitter;

class ActionSendEmail;

class ActionSkipInbox;

class ActionDontStoreMessage;

class ActionRespondWithMessage;

class ActionForwardToUsers;

class ActionSendPushNotification;

class ActionDontSendPushNotification;

class AromaAction;

class Reaction;


class MatcherAll : public virtual ::apache::thrift::TBase {
 public:

  MatcherAll(const MatcherAll&);
  MatcherAll& operator=(const MatcherAll&);
  MatcherAll() {
  }

  virtual ~MatcherAll() throw();

  bool operator == (const MatcherAll & /* rhs */) const
  {
    return true;
  }
  bool operator != (const MatcherAll &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const MatcherAll & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(MatcherAll &a, MatcherAll &b);

std::ostream& operator<<(std::ostream& out, const MatcherAll& obj);

typedef struct _MatcherTitleIs__isset {
  _MatcherTitleIs__isset() : expectedTitle(false) {}
  bool expectedTitle :1;
} _MatcherTitleIs__isset;

class MatcherTitleIs : public virtual ::apache::thrift::TBase {
 public:

  MatcherTitleIs(const MatcherTitleIs&);
  MatcherTitleIs& operator=(const MatcherTitleIs&);
  MatcherTitleIs() : expectedTitle() {
  }

  virtual ~MatcherTitleIs() throw();
  std::string expectedTitle;

  _MatcherTitleIs__isset __isset;

  void __set_expectedTitle(const std::string& val);

  bool operator == (const MatcherTitleIs & rhs) const
  {
    if (!(expectedTitle == rhs.expectedTitle))
      return false;
    return true;
  }
  bool operator != (const MatcherTitleIs &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const MatcherTitleIs & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(MatcherTitleIs &a, MatcherTitleIs &b);

std::ostream& operator<<(std::ostream& out, const MatcherTitleIs& obj);

typedef struct _MatcherTitleIsNot__isset {
  _MatcherTitleIsNot__isset() : title(false) {}
  bool title :1;
} _MatcherTitleIsNot__isset;

class MatcherTitleIsNot : public virtual ::apache::thrift::TBase {
 public:

  MatcherTitleIsNot(const MatcherTitleIsNot&);
  MatcherTitleIsNot& operator=(const MatcherTitleIsNot&);
  MatcherTitleIsNot() : title() {
  }

  virtual ~MatcherTitleIsNot() throw();
  std::string title;

  _MatcherTitleIsNot__isset __isset;

  void __set_title(const std::string& val);

  bool operator == (const MatcherTitleIsNot & rhs) const
  {
    if (!(title == rhs.title))
      return false;
    return true;
  }
  bool operator != (const MatcherTitleIsNot &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const MatcherTitleIsNot & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(MatcherTitleIsNot &a, MatcherTitleIsNot &b);

std::ostream& operator<<(std::ostream& out, const MatcherTitleIsNot& obj);

typedef struct _MatcherTitleContains__isset {
  _MatcherTitleContains__isset() : substring(false) {}
  bool substring :1;
} _MatcherTitleContains__isset;

class MatcherTitleContains : public virtual ::apache::thrift::TBase {
 public:

  MatcherTitleContains(const MatcherTitleContains&);
  MatcherTitleContains& operator=(const MatcherTitleContains&);
  MatcherTitleContains() : substring() {
  }

  virtual ~MatcherTitleContains() throw();
  std::string substring;

  _MatcherTitleContains__isset __isset;

  void __set_substring(const std::string& val);

  bool operator == (const MatcherTitleContains & rhs) const
  {
    if (!(substring == rhs.substring))
      return false;
    return true;
  }
  bool operator != (const MatcherTitleContains &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const MatcherTitleContains & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(MatcherTitleContains &a, MatcherTitleContains &b);

std::ostream& operator<<(std::ostream& out, const MatcherTitleContains& obj);

typedef struct _MatcherTitleDoesNotContain__isset {
  _MatcherTitleDoesNotContain__isset() : substring(false) {}
  bool substring :1;
} _MatcherTitleDoesNotContain__isset;

class MatcherTitleDoesNotContain : public virtual ::apache::thrift::TBase {
 public:

  MatcherTitleDoesNotContain(const MatcherTitleDoesNotContain&);
  MatcherTitleDoesNotContain& operator=(const MatcherTitleDoesNotContain&);
  MatcherTitleDoesNotContain() : substring() {
  }

  virtual ~MatcherTitleDoesNotContain() throw();
  std::string substring;

  _MatcherTitleDoesNotContain__isset __isset;

  void __set_substring(const std::string& val);

  bool operator == (const MatcherTitleDoesNotContain & rhs) const
  {
    if (!(substring == rhs.substring))
      return false;
    return true;
  }
  bool operator != (const MatcherTitleDoesNotContain &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const MatcherTitleDoesNotContain & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(MatcherTitleDoesNotContain &a, MatcherTitleDoesNotContain &b);

std::ostream& operator<<(std::ostream& out, const MatcherTitleDoesNotContain& obj);

typedef struct _MatcherBodyIs__isset {
  _MatcherBodyIs__isset() : expectedBody(false) {}
  bool expectedBody :1;
} _MatcherBodyIs__isset;

class MatcherBodyIs : public virtual ::apache::thrift::TBase {
 public:

  MatcherBodyIs(const MatcherBodyIs&);
  MatcherBodyIs& operator=(const MatcherBodyIs&);
  MatcherBodyIs() : expectedBody() {
  }

  virtual ~MatcherBodyIs() throw();
  std::string expectedBody;

  _MatcherBodyIs__isset __isset;

  void __set_expectedBody(const std::string& val);

  bool operator == (const MatcherBodyIs & rhs) const
  {
    if (!(expectedBody == rhs.expectedBody))
      return false;
    return true;
  }
  bool operator != (const MatcherBodyIs &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const MatcherBodyIs & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(MatcherBodyIs &a, MatcherBodyIs &b);

std::ostream& operator<<(std::ostream& out, const MatcherBodyIs& obj);

typedef struct _MatcherBodyContains__isset {
  _MatcherBodyContains__isset() : substring(false) {}
  bool substring :1;
} _MatcherBodyContains__isset;

class MatcherBodyContains : public virtual ::apache::thrift::TBase {
 public:

  MatcherBodyContains(const MatcherBodyContains&);
  MatcherBodyContains& operator=(const MatcherBodyContains&);
  MatcherBodyContains() : substring() {
  }

  virtual ~MatcherBodyContains() throw();
  std::string substring;

  _MatcherBodyContains__isset __isset;

  void __set_substring(const std::string& val);

  bool operator == (const MatcherBodyContains & rhs) const
  {
    if (!(substring == rhs.substring))
      return false;
    return true;
  }
  bool operator != (const MatcherBodyContains &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const MatcherBodyContains & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(MatcherBodyContains &a, MatcherBodyContains &b);

std::ostream& operator<<(std::ostream& out, const MatcherBodyContains& obj);

typedef struct _MatcherBodyDoesNotContain__isset {
  _MatcherBodyDoesNotContain__isset() : substring(false) {}
  bool substring :1;
} _MatcherBodyDoesNotContain__isset;

class MatcherBodyDoesNotContain : public virtual ::apache::thrift::TBase {
 public:

  MatcherBodyDoesNotContain(const MatcherBodyDoesNotContain&);
  MatcherBodyDoesNotContain& operator=(const MatcherBodyDoesNotContain&);
  MatcherBodyDoesNotContain() : substring() {
  }

  virtual ~MatcherBodyDoesNotContain() throw();
  std::string substring;

  _MatcherBodyDoesNotContain__isset __isset;

  void __set_substring(const std::string& val);

  bool operator == (const MatcherBodyDoesNotContain & rhs) const
  {
    if (!(substring == rhs.substring))
      return false;
    return true;
  }
  bool operator != (const MatcherBodyDoesNotContain &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const MatcherBodyDoesNotContain & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(MatcherBodyDoesNotContain &a, MatcherBodyDoesNotContain &b);

std::ostream& operator<<(std::ostream& out, const MatcherBodyDoesNotContain& obj);

typedef struct _MatcherUrgencyIs__isset {
  _MatcherUrgencyIs__isset() : possibleUrgencies(true) {}
  bool possibleUrgencies :1;
} _MatcherUrgencyIs__isset;

class MatcherUrgencyIs : public virtual ::apache::thrift::TBase {
 public:

  MatcherUrgencyIs(const MatcherUrgencyIs&);
  MatcherUrgencyIs& operator=(const MatcherUrgencyIs&);
  MatcherUrgencyIs() {

  }

  virtual ~MatcherUrgencyIs() throw();
  std::set< ::tech::aroma::thrift::Urgency::type>  possibleUrgencies;

  _MatcherUrgencyIs__isset __isset;

  void __set_possibleUrgencies(const std::set< ::tech::aroma::thrift::Urgency::type> & val);

  bool operator == (const MatcherUrgencyIs & rhs) const
  {
    if (!(possibleUrgencies == rhs.possibleUrgencies))
      return false;
    return true;
  }
  bool operator != (const MatcherUrgencyIs &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const MatcherUrgencyIs & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(MatcherUrgencyIs &a, MatcherUrgencyIs &b);

std::ostream& operator<<(std::ostream& out, const MatcherUrgencyIs& obj);

typedef struct _MatcherHostnameIs__isset {
  _MatcherHostnameIs__isset() : expectedHostname(false) {}
  bool expectedHostname :1;
} _MatcherHostnameIs__isset;

class MatcherHostnameIs : public virtual ::apache::thrift::TBase {
 public:

  MatcherHostnameIs(const MatcherHostnameIs&);
  MatcherHostnameIs& operator=(const MatcherHostnameIs&);
  MatcherHostnameIs() : expectedHostname() {
  }

  virtual ~MatcherHostnameIs() throw();
  std::string expectedHostname;

  _MatcherHostnameIs__isset __isset;

  void __set_expectedHostname(const std::string& val);

  bool operator == (const MatcherHostnameIs & rhs) const
  {
    if (!(expectedHostname == rhs.expectedHostname))
      return false;
    return true;
  }
  bool operator != (const MatcherHostnameIs &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const MatcherHostnameIs & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(MatcherHostnameIs &a, MatcherHostnameIs &b);

std::ostream& operator<<(std::ostream& out, const MatcherHostnameIs& obj);

typedef struct _MatcherHostnameContains__isset {
  _MatcherHostnameContains__isset() : substring(false) {}
  bool substring :1;
} _MatcherHostnameContains__isset;

class MatcherHostnameContains : public virtual ::apache::thrift::TBase {
 public:

  MatcherHostnameContains(const MatcherHostnameContains&);
  MatcherHostnameContains& operator=(const MatcherHostnameContains&);
  MatcherHostnameContains() : substring() {
  }

  virtual ~MatcherHostnameContains() throw();
  std::string substring;

  _MatcherHostnameContains__isset __isset;

  void __set_substring(const std::string& val);

  bool operator == (const MatcherHostnameContains & rhs) const
  {
    if (!(substring == rhs.substring))
      return false;
    return true;
  }
  bool operator != (const MatcherHostnameContains &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const MatcherHostnameContains & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(MatcherHostnameContains &a, MatcherHostnameContains &b);

std::ostream& operator<<(std::ostream& out, const MatcherHostnameContains& obj);

typedef struct _MatcherHostnameDoesNotContain__isset {
  _MatcherHostnameDoesNotContain__isset() : substring(false) {}
  bool substring :1;
} _MatcherHostnameDoesNotContain__isset;

class MatcherHostnameDoesNotContain : public virtual ::apache::thrift::TBase {
 public:

  MatcherHostnameDoesNotContain(const MatcherHostnameDoesNotContain&);
  MatcherHostnameDoesNotContain& operator=(const MatcherHostnameDoesNotContain&);
  MatcherHostnameDoesNotContain() : substring() {
  }

  virtual ~MatcherHostnameDoesNotContain() throw();
  std::string substring;

  _MatcherHostnameDoesNotContain__isset __isset;

  void __set_substring(const std::string& val);

  bool operator == (const MatcherHostnameDoesNotContain & rhs) const
  {
    if (!(substring == rhs.substring))
      return false;
    return true;
  }
  bool operator != (const MatcherHostnameDoesNotContain &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const MatcherHostnameDoesNotContain & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(MatcherHostnameDoesNotContain &a, MatcherHostnameDoesNotContain &b);

std::ostream& operator<<(std::ostream& out, const MatcherHostnameDoesNotContain& obj);

typedef struct _MatcherApplicationIs__isset {
  _MatcherApplicationIs__isset() : appId(false) {}
  bool appId :1;
} _MatcherApplicationIs__isset;

class MatcherApplicationIs : public virtual ::apache::thrift::TBase {
 public:

  MatcherApplicationIs(const MatcherApplicationIs&);
  MatcherApplicationIs& operator=(const MatcherApplicationIs&);
  MatcherApplicationIs() : appId() {
  }

  virtual ~MatcherApplicationIs() throw();
  uuid appId;

  _MatcherApplicationIs__isset __isset;

  void __set_appId(const uuid& val);

  bool operator == (const MatcherApplicationIs & rhs) const
  {
    if (!(appId == rhs.appId))
      return false;
    return true;
  }
  bool operator != (const MatcherApplicationIs &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const MatcherApplicationIs & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(MatcherApplicationIs &a, MatcherApplicationIs &b);

std::ostream& operator<<(std::ostream& out, const MatcherApplicationIs& obj);

typedef struct _MatcherApplicationIsNot__isset {
  _MatcherApplicationIsNot__isset() : appId(false) {}
  bool appId :1;
} _MatcherApplicationIsNot__isset;

class MatcherApplicationIsNot : public virtual ::apache::thrift::TBase {
 public:

  MatcherApplicationIsNot(const MatcherApplicationIsNot&);
  MatcherApplicationIsNot& operator=(const MatcherApplicationIsNot&);
  MatcherApplicationIsNot() : appId() {
  }

  virtual ~MatcherApplicationIsNot() throw();
  uuid appId;

  _MatcherApplicationIsNot__isset __isset;

  void __set_appId(const uuid& val);

  bool operator == (const MatcherApplicationIsNot & rhs) const
  {
    if (!(appId == rhs.appId))
      return false;
    return true;
  }
  bool operator != (const MatcherApplicationIsNot &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const MatcherApplicationIsNot & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(MatcherApplicationIsNot &a, MatcherApplicationIsNot &b);

std::ostream& operator<<(std::ostream& out, const MatcherApplicationIsNot& obj);

typedef struct _AromaMatcher__isset {
  _AromaMatcher__isset() : all(false), titleIs(false), titleIsNot(false), titleContains(false), titleDoesNotContain(false), bodyIs(false), bodyContains(false), bodyDoesNotContain(false), urgencyEquals(false), hostnameIs(false), hostnameContains(false), hostnameDoesNotContain(false), applicationIs(false), applicationIsNot(false) {}
  bool all :1;
  bool titleIs :1;
  bool titleIsNot :1;
  bool titleContains :1;
  bool titleDoesNotContain :1;
  bool bodyIs :1;
  bool bodyContains :1;
  bool bodyDoesNotContain :1;
  bool urgencyEquals :1;
  bool hostnameIs :1;
  bool hostnameContains :1;
  bool hostnameDoesNotContain :1;
  bool applicationIs :1;
  bool applicationIsNot :1;
} _AromaMatcher__isset;

class AromaMatcher : public virtual ::apache::thrift::TBase {
 public:

  AromaMatcher(const AromaMatcher&);
  AromaMatcher& operator=(const AromaMatcher&);
  AromaMatcher() {
  }

  virtual ~AromaMatcher() throw();
  MatcherAll all;
  MatcherTitleIs titleIs;
  MatcherTitleIsNot titleIsNot;
  MatcherTitleContains titleContains;
  MatcherTitleDoesNotContain titleDoesNotContain;
  MatcherBodyIs bodyIs;
  MatcherBodyContains bodyContains;
  MatcherBodyDoesNotContain bodyDoesNotContain;
  MatcherUrgencyIs urgencyEquals;
  MatcherHostnameIs hostnameIs;
  MatcherHostnameContains hostnameContains;
  MatcherHostnameDoesNotContain hostnameDoesNotContain;
  MatcherApplicationIs applicationIs;
  MatcherApplicationIsNot applicationIsNot;

  _AromaMatcher__isset __isset;

  void __set_all(const MatcherAll& val);

  void __set_titleIs(const MatcherTitleIs& val);

  void __set_titleIsNot(const MatcherTitleIsNot& val);

  void __set_titleContains(const MatcherTitleContains& val);

  void __set_titleDoesNotContain(const MatcherTitleDoesNotContain& val);

  void __set_bodyIs(const MatcherBodyIs& val);

  void __set_bodyContains(const MatcherBodyContains& val);

  void __set_bodyDoesNotContain(const MatcherBodyDoesNotContain& val);

  void __set_urgencyEquals(const MatcherUrgencyIs& val);

  void __set_hostnameIs(const MatcherHostnameIs& val);

  void __set_hostnameContains(const MatcherHostnameContains& val);

  void __set_hostnameDoesNotContain(const MatcherHostnameDoesNotContain& val);

  void __set_applicationIs(const MatcherApplicationIs& val);

  void __set_applicationIsNot(const MatcherApplicationIsNot& val);

  bool operator == (const AromaMatcher & rhs) const
  {
    if (__isset.all != rhs.__isset.all)
      return false;
    else if (__isset.all && !(all == rhs.all))
      return false;
    if (__isset.titleIs != rhs.__isset.titleIs)
      return false;
    else if (__isset.titleIs && !(titleIs == rhs.titleIs))
      return false;
    if (__isset.titleIsNot != rhs.__isset.titleIsNot)
      return false;
    else if (__isset.titleIsNot && !(titleIsNot == rhs.titleIsNot))
      return false;
    if (__isset.titleContains != rhs.__isset.titleContains)
      return false;
    else if (__isset.titleContains && !(titleContains == rhs.titleContains))
      return false;
    if (__isset.titleDoesNotContain != rhs.__isset.titleDoesNotContain)
      return false;
    else if (__isset.titleDoesNotContain && !(titleDoesNotContain == rhs.titleDoesNotContain))
      return false;
    if (__isset.bodyIs != rhs.__isset.bodyIs)
      return false;
    else if (__isset.bodyIs && !(bodyIs == rhs.bodyIs))
      return false;
    if (__isset.bodyContains != rhs.__isset.bodyContains)
      return false;
    else if (__isset.bodyContains && !(bodyContains == rhs.bodyContains))
      return false;
    if (__isset.bodyDoesNotContain != rhs.__isset.bodyDoesNotContain)
      return false;
    else if (__isset.bodyDoesNotContain && !(bodyDoesNotContain == rhs.bodyDoesNotContain))
      return false;
    if (__isset.urgencyEquals != rhs.__isset.urgencyEquals)
      return false;
    else if (__isset.urgencyEquals && !(urgencyEquals == rhs.urgencyEquals))
      return false;
    if (__isset.hostnameIs != rhs.__isset.hostnameIs)
      return false;
    else if (__isset.hostnameIs && !(hostnameIs == rhs.hostnameIs))
      return false;
    if (__isset.hostnameContains != rhs.__isset.hostnameContains)
      return false;
    else if (__isset.hostnameContains && !(hostnameContains == rhs.hostnameContains))
      return false;
    if (__isset.hostnameDoesNotContain != rhs.__isset.hostnameDoesNotContain)
      return false;
    else if (__isset.hostnameDoesNotContain && !(hostnameDoesNotContain == rhs.hostnameDoesNotContain))
      return false;
    if (__isset.applicationIs != rhs.__isset.applicationIs)
      return false;
    else if (__isset.applicationIs && !(applicationIs == rhs.applicationIs))
      return false;
    if (__isset.applicationIsNot != rhs.__isset.applicationIsNot)
      return false;
    else if (__isset.applicationIsNot && !(applicationIsNot == rhs.applicationIsNot))
      return false;
    return true;
  }
  bool operator != (const AromaMatcher &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const AromaMatcher & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(AromaMatcher &a, AromaMatcher &b);

std::ostream& operator<<(std::ostream& out, const AromaMatcher& obj);

typedef struct _ActionForwardToSlackChannel__isset {
  _ActionForwardToSlackChannel__isset() : slackChannel(false), includeBody(true), webhookUrl(false), domainName(false) {}
  bool slackChannel :1;
  bool includeBody :1;
  bool webhookUrl :1;
  bool domainName :1;
} _ActionForwardToSlackChannel__isset;

class ActionForwardToSlackChannel : public virtual ::apache::thrift::TBase {
 public:

  ActionForwardToSlackChannel(const ActionForwardToSlackChannel&);
  ActionForwardToSlackChannel& operator=(const ActionForwardToSlackChannel&);
  ActionForwardToSlackChannel() : slackChannel(), includeBody(true), webhookUrl(), domainName() {
  }

  virtual ~ActionForwardToSlackChannel() throw();
  std::string slackChannel;
  bool includeBody;
  std::string webhookUrl;
  std::string domainName;

  _ActionForwardToSlackChannel__isset __isset;

  void __set_slackChannel(const std::string& val);

  void __set_includeBody(const bool val);

  void __set_webhookUrl(const std::string& val);

  void __set_domainName(const std::string& val);

  bool operator == (const ActionForwardToSlackChannel & rhs) const
  {
    if (!(slackChannel == rhs.slackChannel))
      return false;
    if (__isset.includeBody != rhs.__isset.includeBody)
      return false;
    else if (__isset.includeBody && !(includeBody == rhs.includeBody))
      return false;
    if (!(webhookUrl == rhs.webhookUrl))
      return false;
    if (__isset.domainName != rhs.__isset.domainName)
      return false;
    else if (__isset.domainName && !(domainName == rhs.domainName))
      return false;
    return true;
  }
  bool operator != (const ActionForwardToSlackChannel &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const ActionForwardToSlackChannel & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(ActionForwardToSlackChannel &a, ActionForwardToSlackChannel &b);

std::ostream& operator<<(std::ostream& out, const ActionForwardToSlackChannel& obj);

typedef struct _ActionForwardToSlackUser__isset {
  _ActionForwardToSlackUser__isset() : slackUsername(false), includeBody(true), webhookUrl(false), domainName(false) {}
  bool slackUsername :1;
  bool includeBody :1;
  bool webhookUrl :1;
  bool domainName :1;
} _ActionForwardToSlackUser__isset;

class ActionForwardToSlackUser : public virtual ::apache::thrift::TBase {
 public:

  ActionForwardToSlackUser(const ActionForwardToSlackUser&);
  ActionForwardToSlackUser& operator=(const ActionForwardToSlackUser&);
  ActionForwardToSlackUser() : slackUsername(), includeBody(true), webhookUrl(), domainName() {
  }

  virtual ~ActionForwardToSlackUser() throw();
  std::string slackUsername;
  bool includeBody;
  std::string webhookUrl;
  std::string domainName;

  _ActionForwardToSlackUser__isset __isset;

  void __set_slackUsername(const std::string& val);

  void __set_includeBody(const bool val);

  void __set_webhookUrl(const std::string& val);

  void __set_domainName(const std::string& val);

  bool operator == (const ActionForwardToSlackUser & rhs) const
  {
    if (!(slackUsername == rhs.slackUsername))
      return false;
    if (__isset.includeBody != rhs.__isset.includeBody)
      return false;
    else if (__isset.includeBody && !(includeBody == rhs.includeBody))
      return false;
    if (!(webhookUrl == rhs.webhookUrl))
      return false;
    if (__isset.domainName != rhs.__isset.domainName)
      return false;
    else if (__isset.domainName && !(domainName == rhs.domainName))
      return false;
    return true;
  }
  bool operator != (const ActionForwardToSlackUser &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const ActionForwardToSlackUser & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(ActionForwardToSlackUser &a, ActionForwardToSlackUser &b);

std::ostream& operator<<(std::ostream& out, const ActionForwardToSlackUser& obj);

typedef struct _ActionForwardToGitter__isset {
  _ActionForwardToGitter__isset() : gitterWebhookUrl(false), includeBody(true) {}
  bool gitterWebhookUrl :1;
  bool includeBody :1;
} _ActionForwardToGitter__isset;

class ActionForwardToGitter : public virtual ::apache::thrift::TBase {
 public:

  ActionForwardToGitter(const ActionForwardToGitter&);
  ActionForwardToGitter& operator=(const ActionForwardToGitter&);
  ActionForwardToGitter() : gitterWebhookUrl(), includeBody(true) {
  }

  virtual ~ActionForwardToGitter() throw();
  std::string gitterWebhookUrl;
  bool includeBody;

  _ActionForwardToGitter__isset __isset;

  void __set_gitterWebhookUrl(const std::string& val);

  void __set_includeBody(const bool val);

  bool operator == (const ActionForwardToGitter & rhs) const
  {
    if (!(gitterWebhookUrl == rhs.gitterWebhookUrl))
      return false;
    if (__isset.includeBody != rhs.__isset.includeBody)
      return false;
    else if (__isset.includeBody && !(includeBody == rhs.includeBody))
      return false;
    return true;
  }
  bool operator != (const ActionForwardToGitter &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const ActionForwardToGitter & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(ActionForwardToGitter &a, ActionForwardToGitter &b);

std::ostream& operator<<(std::ostream& out, const ActionForwardToGitter& obj);

typedef struct _ActionSendEmail__isset {
  _ActionSendEmail__isset() : emailAddress(false), includeBody(true) {}
  bool emailAddress :1;
  bool includeBody :1;
} _ActionSendEmail__isset;

class ActionSendEmail : public virtual ::apache::thrift::TBase {
 public:

  ActionSendEmail(const ActionSendEmail&);
  ActionSendEmail& operator=(const ActionSendEmail&);
  ActionSendEmail() : emailAddress(), includeBody(true) {
  }

  virtual ~ActionSendEmail() throw();
  std::string emailAddress;
  bool includeBody;

  _ActionSendEmail__isset __isset;

  void __set_emailAddress(const std::string& val);

  void __set_includeBody(const bool val);

  bool operator == (const ActionSendEmail & rhs) const
  {
    if (!(emailAddress == rhs.emailAddress))
      return false;
    if (__isset.includeBody != rhs.__isset.includeBody)
      return false;
    else if (__isset.includeBody && !(includeBody == rhs.includeBody))
      return false;
    return true;
  }
  bool operator != (const ActionSendEmail &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const ActionSendEmail & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(ActionSendEmail &a, ActionSendEmail &b);

std::ostream& operator<<(std::ostream& out, const ActionSendEmail& obj);


class ActionSkipInbox : public virtual ::apache::thrift::TBase {
 public:

  ActionSkipInbox(const ActionSkipInbox&);
  ActionSkipInbox& operator=(const ActionSkipInbox&);
  ActionSkipInbox() {
  }

  virtual ~ActionSkipInbox() throw();

  bool operator == (const ActionSkipInbox & /* rhs */) const
  {
    return true;
  }
  bool operator != (const ActionSkipInbox &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const ActionSkipInbox & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(ActionSkipInbox &a, ActionSkipInbox &b);

std::ostream& operator<<(std::ostream& out, const ActionSkipInbox& obj);


class ActionDontStoreMessage : public virtual ::apache::thrift::TBase {
 public:

  ActionDontStoreMessage(const ActionDontStoreMessage&);
  ActionDontStoreMessage& operator=(const ActionDontStoreMessage&);
  ActionDontStoreMessage() {
  }

  virtual ~ActionDontStoreMessage() throw();

  bool operator == (const ActionDontStoreMessage & /* rhs */) const
  {
    return true;
  }
  bool operator != (const ActionDontStoreMessage &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const ActionDontStoreMessage & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(ActionDontStoreMessage &a, ActionDontStoreMessage &b);

std::ostream& operator<<(std::ostream& out, const ActionDontStoreMessage& obj);

typedef struct _ActionRespondWithMessage__isset {
  _ActionRespondWithMessage__isset() : messageToRespondWith(false) {}
  bool messageToRespondWith :1;
} _ActionRespondWithMessage__isset;

class ActionRespondWithMessage : public virtual ::apache::thrift::TBase {
 public:

  ActionRespondWithMessage(const ActionRespondWithMessage&);
  ActionRespondWithMessage& operator=(const ActionRespondWithMessage&);
  ActionRespondWithMessage() : messageToRespondWith() {
  }

  virtual ~ActionRespondWithMessage() throw();
  std::string messageToRespondWith;

  _ActionRespondWithMessage__isset __isset;

  void __set_messageToRespondWith(const std::string& val);

  bool operator == (const ActionRespondWithMessage & rhs) const
  {
    if (!(messageToRespondWith == rhs.messageToRespondWith))
      return false;
    return true;
  }
  bool operator != (const ActionRespondWithMessage &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const ActionRespondWithMessage & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(ActionRespondWithMessage &a, ActionRespondWithMessage &b);

std::ostream& operator<<(std::ostream& out, const ActionRespondWithMessage& obj);

typedef struct _ActionForwardToUsers__isset {
  _ActionForwardToUsers__isset() : userIds(true) {}
  bool userIds :1;
} _ActionForwardToUsers__isset;

class ActionForwardToUsers : public virtual ::apache::thrift::TBase {
 public:

  ActionForwardToUsers(const ActionForwardToUsers&);
  ActionForwardToUsers& operator=(const ActionForwardToUsers&);
  ActionForwardToUsers() {

  }

  virtual ~ActionForwardToUsers() throw();
  std::vector<uuid>  userIds;

  _ActionForwardToUsers__isset __isset;

  void __set_userIds(const std::vector<uuid> & val);

  bool operator == (const ActionForwardToUsers & rhs) const
  {
    if (!(userIds == rhs.userIds))
      return false;
    return true;
  }
  bool operator != (const ActionForwardToUsers &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const ActionForwardToUsers & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(ActionForwardToUsers &a, ActionForwardToUsers &b);

std::ostream& operator<<(std::ostream& out, const ActionForwardToUsers& obj);


class ActionSendPushNotification : public virtual ::apache::thrift::TBase {
 public:

  ActionSendPushNotification(const ActionSendPushNotification&);
  ActionSendPushNotification& operator=(const ActionSendPushNotification&);
  ActionSendPushNotification() {
  }

  virtual ~ActionSendPushNotification() throw();

  bool operator == (const ActionSendPushNotification & /* rhs */) const
  {
    return true;
  }
  bool operator != (const ActionSendPushNotification &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const ActionSendPushNotification & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(ActionSendPushNotification &a, ActionSendPushNotification &b);

std::ostream& operator<<(std::ostream& out, const ActionSendPushNotification& obj);


class ActionDontSendPushNotification : public virtual ::apache::thrift::TBase {
 public:

  ActionDontSendPushNotification(const ActionDontSendPushNotification&);
  ActionDontSendPushNotification& operator=(const ActionDontSendPushNotification&);
  ActionDontSendPushNotification() {
  }

  virtual ~ActionDontSendPushNotification() throw();

  bool operator == (const ActionDontSendPushNotification & /* rhs */) const
  {
    return true;
  }
  bool operator != (const ActionDontSendPushNotification &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const ActionDontSendPushNotification & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(ActionDontSendPushNotification &a, ActionDontSendPushNotification &b);

std::ostream& operator<<(std::ostream& out, const ActionDontSendPushNotification& obj);

typedef struct _AromaAction__isset {
  _AromaAction__isset() : forwardToSlackChannel(false), forwardToSlackUser(false), forwardToGitter(false), sendEmail(false), skipInbox(false), dontStoreMessage(false), responseWithMessage(false), forwardToUsers(false), sendPushNotification(false), dontSendPushNotification(false) {}
  bool forwardToSlackChannel :1;
  bool forwardToSlackUser :1;
  bool forwardToGitter :1;
  bool sendEmail :1;
  bool skipInbox :1;
  bool dontStoreMessage :1;
  bool responseWithMessage :1;
  bool forwardToUsers :1;
  bool sendPushNotification :1;
  bool dontSendPushNotification :1;
} _AromaAction__isset;

class AromaAction : public virtual ::apache::thrift::TBase {
 public:

  AromaAction(const AromaAction&);
  AromaAction& operator=(const AromaAction&);
  AromaAction() {
  }

  virtual ~AromaAction() throw();
  ActionForwardToSlackChannel forwardToSlackChannel;
  ActionForwardToSlackUser forwardToSlackUser;
  ActionForwardToGitter forwardToGitter;
  ActionSendEmail sendEmail;
  ActionSkipInbox skipInbox;
  ActionDontStoreMessage dontStoreMessage;
  ActionRespondWithMessage responseWithMessage;
  ActionForwardToUsers forwardToUsers;
  ActionSendPushNotification sendPushNotification;
  ActionDontSendPushNotification dontSendPushNotification;

  _AromaAction__isset __isset;

  void __set_forwardToSlackChannel(const ActionForwardToSlackChannel& val);

  void __set_forwardToSlackUser(const ActionForwardToSlackUser& val);

  void __set_forwardToGitter(const ActionForwardToGitter& val);

  void __set_sendEmail(const ActionSendEmail& val);

  void __set_skipInbox(const ActionSkipInbox& val);

  void __set_dontStoreMessage(const ActionDontStoreMessage& val);

  void __set_responseWithMessage(const ActionRespondWithMessage& val);

  void __set_forwardToUsers(const ActionForwardToUsers& val);

  void __set_sendPushNotification(const ActionSendPushNotification& val);

  void __set_dontSendPushNotification(const ActionDontSendPushNotification& val);

  bool operator == (const AromaAction & rhs) const
  {
    if (__isset.forwardToSlackChannel != rhs.__isset.forwardToSlackChannel)
      return false;
    else if (__isset.forwardToSlackChannel && !(forwardToSlackChannel == rhs.forwardToSlackChannel))
      return false;
    if (__isset.forwardToSlackUser != rhs.__isset.forwardToSlackUser)
      return false;
    else if (__isset.forwardToSlackUser && !(forwardToSlackUser == rhs.forwardToSlackUser))
      return false;
    if (__isset.forwardToGitter != rhs.__isset.forwardToGitter)
      return false;
    else if (__isset.forwardToGitter && !(forwardToGitter == rhs.forwardToGitter))
      return false;
    if (__isset.sendEmail != rhs.__isset.sendEmail)
      return false;
    else if (__isset.sendEmail && !(sendEmail == rhs.sendEmail))
      return false;
    if (__isset.skipInbox != rhs.__isset.skipInbox)
      return false;
    else if (__isset.skipInbox && !(skipInbox == rhs.skipInbox))
      return false;
    if (__isset.dontStoreMessage != rhs.__isset.dontStoreMessage)
      return false;
    else if (__isset.dontStoreMessage && !(dontStoreMessage == rhs.dontStoreMessage))
      return false;
    if (__isset.responseWithMessage != rhs.__isset.responseWithMessage)
      return false;
    else if (__isset.responseWithMessage && !(responseWithMessage == rhs.responseWithMessage))
      return false;
    if (__isset.forwardToUsers != rhs.__isset.forwardToUsers)
      return false;
    else if (__isset.forwardToUsers && !(forwardToUsers == rhs.forwardToUsers))
      return false;
    if (__isset.sendPushNotification != rhs.__isset.sendPushNotification)
      return false;
    else if (__isset.sendPushNotification && !(sendPushNotification == rhs.sendPushNotification))
      return false;
    if (__isset.dontSendPushNotification != rhs.__isset.dontSendPushNotification)
      return false;
    else if (__isset.dontSendPushNotification && !(dontSendPushNotification == rhs.dontSendPushNotification))
      return false;
    return true;
  }
  bool operator != (const AromaAction &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const AromaAction & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(AromaAction &a, AromaAction &b);

std::ostream& operator<<(std::ostream& out, const AromaAction& obj);

typedef struct _Reaction__isset {
  _Reaction__isset() : matchers(true), actions(true), name(false) {}
  bool matchers :1;
  bool actions :1;
  bool name :1;
} _Reaction__isset;

class Reaction : public virtual ::apache::thrift::TBase {
 public:

  Reaction(const Reaction&);
  Reaction& operator=(const Reaction&);
  Reaction() : name() {


  }

  virtual ~Reaction() throw();
  std::vector<AromaMatcher>  matchers;
  std::vector<AromaAction>  actions;
  std::string name;

  _Reaction__isset __isset;

  void __set_matchers(const std::vector<AromaMatcher> & val);

  void __set_actions(const std::vector<AromaAction> & val);

  void __set_name(const std::string& val);

  bool operator == (const Reaction & rhs) const
  {
    if (!(matchers == rhs.matchers))
      return false;
    if (!(actions == rhs.actions))
      return false;
    if (!(name == rhs.name))
      return false;
    return true;
  }
  bool operator != (const Reaction &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Reaction & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(Reaction &a, Reaction &b);

std::ostream& operator<<(std::ostream& out, const Reaction& obj);

}}}} // namespace

#endif
