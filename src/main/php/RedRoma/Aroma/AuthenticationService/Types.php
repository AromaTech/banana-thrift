<?php
namespace RedRoma\Aroma\AuthenticationService;

/**
 * Autogenerated by Thrift Compiler (0.9.3)
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *  @generated
 */
use Thrift\Base\TBase;
use Thrift\Type\TType;
use Thrift\Type\TMessageType;
use Thrift\Exception\TException;
use Thrift\Exception\TProtocolException;
use Thrift\Protocol\TProtocol;
use Thrift\Protocol\TBinaryProtocolAccelerated;
use Thrift\Exception\TApplicationException;


class CreateTokenRequest {
  static $_TSPEC;

  /**
   * The ID of the entity that will own the token.
   * For Application tokens, this is the Application ID.
   * For User Tokens, this is the userId.
   * 
   * @var string
   */
  public $ownerId = null;
  /**
   * The desired length of time to keep the Token alive and valid.
   * If not present, will be set to DEFAULT_TOKEN_LIFETIME.
   * 
   * @var \RedRoma\Aroma\LengthOfTime
   */
  public $lifetime = null;
  /**
   * This is required, and determines the kind of Token created.
   * 
   * @var int
   */
  public $desiredTokenType = null;
  /**
   * Optional stores the name of the entity owning the token, for instance App name or user's email.
   * 
   * @var string
   */
  public $ownerName = null;
  /**
   * @var string
   */
  public $organizationId = null;
  /**
   * @var string
   */
  public $organizationName = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'ownerId',
          'type' => TType::STRING,
          ),
        2 => array(
          'var' => 'lifetime',
          'type' => TType::STRUCT,
          'class' => '\RedRoma\Aroma\LengthOfTime',
          ),
        3 => array(
          'var' => 'desiredTokenType',
          'type' => TType::I32,
          ),
        4 => array(
          'var' => 'ownerName',
          'type' => TType::STRING,
          ),
        5 => array(
          'var' => 'organizationId',
          'type' => TType::STRING,
          ),
        6 => array(
          'var' => 'organizationName',
          'type' => TType::STRING,
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['ownerId'])) {
        $this->ownerId = $vals['ownerId'];
      }
      if (isset($vals['lifetime'])) {
        $this->lifetime = $vals['lifetime'];
      }
      if (isset($vals['desiredTokenType'])) {
        $this->desiredTokenType = $vals['desiredTokenType'];
      }
      if (isset($vals['ownerName'])) {
        $this->ownerName = $vals['ownerName'];
      }
      if (isset($vals['organizationId'])) {
        $this->organizationId = $vals['organizationId'];
      }
      if (isset($vals['organizationName'])) {
        $this->organizationName = $vals['organizationName'];
      }
    }
  }

  public function getName() {
    return 'CreateTokenRequest';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->ownerId);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::STRUCT) {
            $this->lifetime = new \RedRoma\Aroma\LengthOfTime();
            $xfer += $this->lifetime->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 3:
          if ($ftype == TType::I32) {
            $xfer += $input->readI32($this->desiredTokenType);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 4:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->ownerName);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 5:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->organizationId);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 6:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->organizationName);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('CreateTokenRequest');
    if ($this->ownerId !== null) {
      $xfer += $output->writeFieldBegin('ownerId', TType::STRING, 1);
      $xfer += $output->writeString($this->ownerId);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->lifetime !== null) {
      if (!is_object($this->lifetime)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('lifetime', TType::STRUCT, 2);
      $xfer += $this->lifetime->write($output);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->desiredTokenType !== null) {
      $xfer += $output->writeFieldBegin('desiredTokenType', TType::I32, 3);
      $xfer += $output->writeI32($this->desiredTokenType);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->ownerName !== null) {
      $xfer += $output->writeFieldBegin('ownerName', TType::STRING, 4);
      $xfer += $output->writeString($this->ownerName);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->organizationId !== null) {
      $xfer += $output->writeFieldBegin('organizationId', TType::STRING, 5);
      $xfer += $output->writeString($this->organizationId);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->organizationName !== null) {
      $xfer += $output->writeFieldBegin('organizationName', TType::STRING, 6);
      $xfer += $output->writeString($this->organizationName);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class CreateTokenResponse {
  static $_TSPEC;

  /**
   * @var \RedRoma\Aroma\Authentication\AuthenticationToken
   */
  public $token = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'token',
          'type' => TType::STRUCT,
          'class' => '\RedRoma\Aroma\Authentication\AuthenticationToken',
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['token'])) {
        $this->token = $vals['token'];
      }
    }
  }

  public function getName() {
    return 'CreateTokenResponse';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRUCT) {
            $this->token = new \RedRoma\Aroma\Authentication\AuthenticationToken();
            $xfer += $this->token->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('CreateTokenResponse');
    if ($this->token !== null) {
      if (!is_object($this->token)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('token', TType::STRUCT, 1);
      $xfer += $this->token->write($output);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class GetTokenInfoRequest {
  static $_TSPEC;

  /**
   * @var string
   */
  public $tokenId = null;
  /**
   * @var int
   */
  public $tokenType = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'tokenId',
          'type' => TType::STRING,
          ),
        2 => array(
          'var' => 'tokenType',
          'type' => TType::I32,
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['tokenId'])) {
        $this->tokenId = $vals['tokenId'];
      }
      if (isset($vals['tokenType'])) {
        $this->tokenType = $vals['tokenType'];
      }
    }
  }

  public function getName() {
    return 'GetTokenInfoRequest';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->tokenId);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::I32) {
            $xfer += $input->readI32($this->tokenType);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('GetTokenInfoRequest');
    if ($this->tokenId !== null) {
      $xfer += $output->writeFieldBegin('tokenId', TType::STRING, 1);
      $xfer += $output->writeString($this->tokenId);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->tokenType !== null) {
      $xfer += $output->writeFieldBegin('tokenType', TType::I32, 2);
      $xfer += $output->writeI32($this->tokenType);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class GetTokenInfoResponse {
  static $_TSPEC;

  /**
   * @var \RedRoma\Aroma\Authentication\AuthenticationToken
   */
  public $token = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'token',
          'type' => TType::STRUCT,
          'class' => '\RedRoma\Aroma\Authentication\AuthenticationToken',
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['token'])) {
        $this->token = $vals['token'];
      }
    }
  }

  public function getName() {
    return 'GetTokenInfoResponse';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRUCT) {
            $this->token = new \RedRoma\Aroma\Authentication\AuthenticationToken();
            $xfer += $this->token->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('GetTokenInfoResponse');
    if ($this->token !== null) {
      if (!is_object($this->token)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('token', TType::STRUCT, 1);
      $xfer += $this->token->write($output);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class InvalidateTokenRequest {
  static $_TSPEC;

  /**
   * @var \RedRoma\Aroma\Authentication\AuthenticationToken
   */
  public $token = null;
  /**
   * @var \RedRoma\Aroma\Authentication\AuthenticationToken[]
   */
  public $multipleTokens = array(
  );
  /**
   * Deletes all Tokens belonging to this ownerId.
   * 
   * @var string
   */
  public $belongingTo = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'token',
          'type' => TType::STRUCT,
          'class' => '\RedRoma\Aroma\Authentication\AuthenticationToken',
          ),
        2 => array(
          'var' => 'multipleTokens',
          'type' => TType::LST,
          'etype' => TType::STRUCT,
          'elem' => array(
            'type' => TType::STRUCT,
            'class' => '\RedRoma\Aroma\Authentication\AuthenticationToken',
            ),
          ),
        3 => array(
          'var' => 'belongingTo',
          'type' => TType::STRING,
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['token'])) {
        $this->token = $vals['token'];
      }
      if (isset($vals['multipleTokens'])) {
        $this->multipleTokens = $vals['multipleTokens'];
      }
      if (isset($vals['belongingTo'])) {
        $this->belongingTo = $vals['belongingTo'];
      }
    }
  }

  public function getName() {
    return 'InvalidateTokenRequest';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRUCT) {
            $this->token = new \RedRoma\Aroma\Authentication\AuthenticationToken();
            $xfer += $this->token->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::LST) {
            $this->multipleTokens = array();
            $_size0 = 0;
            $_etype3 = 0;
            $xfer += $input->readListBegin($_etype3, $_size0);
            for ($_i4 = 0; $_i4 < $_size0; ++$_i4)
            {
              $elem5 = null;
              $elem5 = new \RedRoma\Aroma\Authentication\AuthenticationToken();
              $xfer += $elem5->read($input);
              $this->multipleTokens []= $elem5;
            }
            $xfer += $input->readListEnd();
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 3:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->belongingTo);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('InvalidateTokenRequest');
    if ($this->token !== null) {
      if (!is_object($this->token)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('token', TType::STRUCT, 1);
      $xfer += $this->token->write($output);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->multipleTokens !== null) {
      if (!is_array($this->multipleTokens)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('multipleTokens', TType::LST, 2);
      {
        $output->writeListBegin(TType::STRUCT, count($this->multipleTokens));
        {
          foreach ($this->multipleTokens as $iter6)
          {
            $xfer += $iter6->write($output);
          }
        }
        $output->writeListEnd();
      }
      $xfer += $output->writeFieldEnd();
    }
    if ($this->belongingTo !== null) {
      $xfer += $output->writeFieldBegin('belongingTo', TType::STRING, 3);
      $xfer += $output->writeString($this->belongingTo);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class InvalidateTokenResponse {
  static $_TSPEC;

  /**
   * @var string
   */
  public $message = "Operation completed successfully";

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'message',
          'type' => TType::STRING,
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['message'])) {
        $this->message = $vals['message'];
      }
    }
  }

  public function getName() {
    return 'InvalidateTokenResponse';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->message);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('InvalidateTokenResponse');
    if ($this->message !== null) {
      $xfer += $output->writeFieldBegin('message', TType::STRING, 1);
      $xfer += $output->writeString($this->message);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class VerifyTokenRequest {
  static $_TSPEC;

  /**
   * @var string
   */
  public $tokenId = null;
  /**
   * If included, the operation will also verify that the token belongs to this Owner ID.
   * 
   * @var string
   */
  public $ownerId = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'tokenId',
          'type' => TType::STRING,
          ),
        2 => array(
          'var' => 'ownerId',
          'type' => TType::STRING,
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['tokenId'])) {
        $this->tokenId = $vals['tokenId'];
      }
      if (isset($vals['ownerId'])) {
        $this->ownerId = $vals['ownerId'];
      }
    }
  }

  public function getName() {
    return 'VerifyTokenRequest';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->tokenId);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->ownerId);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('VerifyTokenRequest');
    if ($this->tokenId !== null) {
      $xfer += $output->writeFieldBegin('tokenId', TType::STRING, 1);
      $xfer += $output->writeString($this->tokenId);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->ownerId !== null) {
      $xfer += $output->writeFieldBegin('ownerId', TType::STRING, 2);
      $xfer += $output->writeString($this->ownerId);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class VerifyTokenResponse {
  static $_TSPEC;

  /**
   * @var string
   */
  public $message = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'message',
          'type' => TType::STRING,
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['message'])) {
        $this->message = $vals['message'];
      }
    }
  }

  public function getName() {
    return 'VerifyTokenResponse';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->message);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('VerifyTokenResponse');
    if ($this->message !== null) {
      $xfer += $output->writeFieldBegin('message', TType::STRING, 1);
      $xfer += $output->writeString($this->message);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

final class Constant extends \Thrift\Type\TConstant {
  static protected $SERVICE_PORT;
  static protected $PRODUCTION_ENDPOINT;
  static protected $BETA_ENDPOINT;
  static protected $DEFAULT_TOKEN_LIFETIME;

  static protected function init_SERVICE_PORT() {
    return 7026;
  }

  static protected function init_PRODUCTION_ENDPOINT() {
    return new \RedRoma\Aroma\Endpoint\TcpEndpoint(array(
      "hostname" => "authentication-srv.aroma.tech",
      "port" => 7026,
    ));
  }

  static protected function init_BETA_ENDPOINT() {
    return new \RedRoma\Aroma\Endpoint\TcpEndpoint(array(
      "hostname" => "authentication-srv.beta.aroma.tech",
      "port" => 7026,
    ));
  }

  static protected function init_DEFAULT_TOKEN_LIFETIME() {
    return     /**
     * The Default lifetime of a Token created by the Authentication Service.
     */
new \RedRoma\Aroma\LengthOfTime(array(
      "value" => 60,
      "unit" =>       5,
    ));
  }
}


